// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.40.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Interest>>
abstract class Interest implements RustOpaqueInterface {
  /// Add together two `Interest` values.
  ///
  /// This function works from a `const` context.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::io::Interest;
  ///
  /// const BOTH: Interest = Interest::READABLE.add(Interest::WRITABLE);
  ///
  /// assert!(BOTH.is_readable());
  /// assert!(BOTH.is_writable());
  Future<Interest> add({required Interest other});

  /// Returns true if the value includes error interest.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::io::Interest;
  ///
  /// assert!(Interest::ERROR.is_error());
  /// assert!(!Interest::WRITABLE.is_error());
  ///
  /// let combined = Interest::READABLE | Interest::ERROR;
  /// assert!(combined.is_error());
  /// ```
  Future<bool> isError();

  /// Returns true if the value includes readable interest.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::io::Interest;
  ///
  /// assert!(Interest::READABLE.is_readable());
  /// assert!(!Interest::WRITABLE.is_readable());
  ///
  /// let both = Interest::READABLE | Interest::WRITABLE;
  /// assert!(both.is_readable());
  /// ```
  Future<bool> isReadable();

  /// Returns true if the value includes writable interest.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::io::Interest;
  ///
  /// assert!(!Interest::READABLE.is_writable());
  /// assert!(Interest::WRITABLE.is_writable());
  ///
  /// let both = Interest::READABLE | Interest::WRITABLE;
  /// assert!(both.is_writable());
  /// ```
  Future<bool> isWritable();

  /// Remove `Interest` from `self`.
  ///
  /// Interests present in `other` but *not* in `self` are ignored.
  ///
  /// Returns `None` if the set would be empty after removing `Interest`.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::io::Interest;
  ///
  /// const RW_INTEREST: Interest = Interest::READABLE.add(Interest::WRITABLE);
  ///
  /// let w_interest = RW_INTEREST.remove(Interest::READABLE).unwrap();
  /// assert!(!w_interest.is_readable());
  /// assert!(w_interest.is_writable());
  ///
  /// // Removing all interests from the set returns `None`.
  /// assert_eq!(w_interest.remove(Interest::WRITABLE), None);
  ///
  /// // Remove all interests at once.
  /// assert_eq!(RW_INTEREST.remove(RW_INTEREST), None);
  /// ```
  Future<Interest?> remove({required Interest other});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Ready>>
abstract class Ready implements RustOpaqueInterface {
  /// Returns true if `Ready` is the empty set.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::io::Ready;
  ///
  /// assert!(Ready::EMPTY.is_empty());
  /// assert!(!Ready::READABLE.is_empty());
  /// ```
  Future<bool> isEmpty();

  /// Returns `true` if the value includes error `readiness`.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::io::Ready;
  ///
  /// assert!(!Ready::EMPTY.is_error());
  /// assert!(!Ready::WRITABLE.is_error());
  /// assert!(Ready::ERROR.is_error());
  /// ```
  Future<bool> isError();

  /// Returns `true` if the value includes read-closed `readiness`.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::io::Ready;
  ///
  /// assert!(!Ready::EMPTY.is_read_closed());
  /// assert!(!Ready::READABLE.is_read_closed());
  /// assert!(Ready::READ_CLOSED.is_read_closed());
  /// ```
  Future<bool> isReadClosed();

  /// Returns `true` if the value includes `readable`.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::io::Ready;
  ///
  /// assert!(!Ready::EMPTY.is_readable());
  /// assert!(Ready::READABLE.is_readable());
  /// assert!(Ready::READ_CLOSED.is_readable());
  /// assert!(!Ready::WRITABLE.is_readable());
  /// ```
  Future<bool> isReadable();

  /// Returns `true` if the value includes writable `readiness`.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::io::Ready;
  ///
  /// assert!(!Ready::EMPTY.is_writable());
  /// assert!(!Ready::READABLE.is_writable());
  /// assert!(Ready::WRITABLE.is_writable());
  /// assert!(Ready::WRITE_CLOSED.is_writable());
  /// ```
  Future<bool> isWritable();

  /// Returns `true` if the value includes write-closed `readiness`.
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::io::Ready;
  ///
  /// assert!(!Ready::EMPTY.is_write_closed());
  /// assert!(!Ready::WRITABLE.is_write_closed());
  /// assert!(Ready::WRITE_CLOSED.is_write_closed());
  /// ```
  Future<bool> isWriteClosed();
}
