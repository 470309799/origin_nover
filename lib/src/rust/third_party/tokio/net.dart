// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.40.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../../lib.dart';
import 'io.dart';
import 'net/tcp/listener.dart';
import 'net/tcp/stream.dart';
import 'net/udp.dart';
import 'net/windows/named_pipe.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'signal/windows.dart';
import 'time/error.dart';

// These functions are ignored because they have generic arguments: `lookup_host`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TcpListener>>
abstract class TcpListener implements RustOpaqueInterface {
  /// Accepts a new incoming connection from this listener.
  ///
  /// This function will yield once a new TCP connection is established. When
  /// established, the corresponding [`TcpStream`] and the remote peer's
  /// address will be returned.
  ///
  /// # Cancel safety
  ///
  /// This method is cancel safe. If the method is used as the event in a
  /// [`tokio::select!`](crate::select) statement and some other branch
  /// completes first, then it is guaranteed that no new connections were
  /// accepted by this method.
  ///
  /// [`TcpStream`]: struct@crate::net::TcpStream
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::TcpListener;
  ///
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     let listener = TcpListener::bind("127.0.0.1:8080").await?;
  ///
  ///     match listener.accept().await {
  ///         Ok((_socket, addr)) => println!("new client: {:?}", addr),
  ///         Err(e) => println!("couldn't get client: {:?}", e),
  ///     }
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<(TcpStream, SocketAddr)> accept();

  /// Creates new `TcpListener` from a `std::net::TcpListener`.
  ///
  /// This function is intended to be used to wrap a TCP listener from the
  /// standard library in the Tokio equivalent.
  ///
  /// This API is typically paired with the `socket2` crate and the `Socket`
  /// type to build up and customize a listener before it's shipped off to the
  /// backing event loop. This allows configuration of options like
  /// `SO_REUSEPORT`, binding to multiple addresses, etc.
  ///
  /// # Notes
  ///
  /// The caller is responsible for ensuring that the listener is in
  /// non-blocking mode. Otherwise all I/O operations on the listener
  /// will block the thread, which will cause unexpected behavior.
  /// Non-blocking mode can be set using [`set_nonblocking`].
  ///
  /// [`set_nonblocking`]: std::net::TcpListener::set_nonblocking
  ///
  /// # Examples
  ///
  /// ```rust,no_run
  /// use std::error::Error;
  /// use tokio::net::TcpListener;
  ///
  /// #[tokio::main]
  /// async fn main() -> Result<(), Box<dyn Error>> {
  ///     let std_listener = std::net::TcpListener::bind("127.0.0.1:0")?;
  ///     std_listener.set_nonblocking(true)?;
  ///     let listener = TcpListener::from_std(std_listener)?;
  ///     Ok(())
  /// }
  /// ```
  ///
  /// # Panics
  ///
  /// This function panics if it is not called from within a runtime with
  /// IO enabled.
  ///
  /// The runtime is usually set implicitly when this function is called
  /// from a future driven by a tokio runtime, otherwise runtime can be set
  /// explicitly with [`Runtime::enter`](crate::runtime::Runtime::enter) function.
  static Future<TcpListener> fromStd({required TcpListener listener}) =>
      RustLib.instance.api.tokioNetTcpListenerFromStd(listener: listener);

  /// Turns a [`tokio::net::TcpListener`] into a [`std::net::TcpListener`].
  ///
  /// The returned [`std::net::TcpListener`] will have nonblocking mode set as
  /// `true`.  Use [`set_nonblocking`] to change the blocking mode if needed.
  ///
  /// # Examples
  ///
  /// ```rust,no_run
  /// use std::error::Error;
  ///
  /// #[tokio::main]
  /// async fn main() -> Result<(), Box<dyn Error>> {
  ///     let tokio_listener = tokio::net::TcpListener::bind("127.0.0.1:0").await?;
  ///     let std_listener = tokio_listener.into_std()?;
  ///     std_listener.set_nonblocking(false)?;
  ///     Ok(())
  /// }
  /// ```
  ///
  /// [`tokio::net::TcpListener`]: TcpListener
  /// [`std::net::TcpListener`]: std::net::TcpListener
  /// [`set_nonblocking`]: fn@std::net::TcpListener::set_nonblocking
  Future<TcpListener> intoStd();

  /// Returns the local address that this listener is bound to.
  ///
  /// This can be useful, for example, when binding to port 0 to figure out
  /// which port was actually bound.
  ///
  /// # Examples
  ///
  /// ```rust,no_run
  /// use tokio::net::TcpListener;
  ///
  /// use std::io;
  /// use std::net::{Ipv4Addr, SocketAddr, SocketAddrV4};
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     let listener = TcpListener::bind("127.0.0.1:8080").await?;
  ///
  ///     assert_eq!(listener.local_addr()?,
  ///                SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080)));
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<SocketAddr> localAddr();

  /// Polls to accept a new incoming connection to this listener.
  ///
  /// If there is no connection to accept, `Poll::Pending` is returned and the
  /// current task will be notified by a waker.  Note that on multiple calls
  /// to `poll_accept`, only the `Waker` from the `Context` passed to the most
  /// recent call is scheduled to receive a wakeup.
  Future<PollResultTcpStreamSocketAddr> pollAccept({required Context cx});

  /// Sets the value for the `IP_TTL` option on this socket.
  ///
  /// This value sets the time-to-live field that is used in every packet sent
  /// from this socket.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::TcpListener;
  ///
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     let listener = TcpListener::bind("127.0.0.1:0").await?;
  ///
  ///     listener.set_ttl(100).expect("could not set TTL");
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<void> setTtl({required int ttl});

  /// Gets the value of the `IP_TTL` option for this socket.
  ///
  /// For more information about this option, see [`set_ttl`].
  ///
  /// [`set_ttl`]: method@Self::set_ttl
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::TcpListener;
  ///
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///    let listener = TcpListener::bind("127.0.0.1:0").await?;
  ///
  ///    listener.set_ttl(100).expect("could not set TTL");
  ///    assert_eq!(listener.ttl()?, 100);
  ///
  ///    Ok(())
  /// }
  /// ```
  Future<int> ttl();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TcpSocket>>
abstract class TcpSocket implements RustOpaqueInterface {
  /// Binds the socket to the given address.
  ///
  /// This calls the `bind(2)` operating-system function. Behavior is
  /// platform specific. Refer to the target platform's documentation for more
  /// details.
  ///
  /// # Examples
  ///
  /// Bind a socket before listening.
  ///
  /// ```no_run
  /// use tokio::net::TcpSocket;
  ///
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     let addr = "127.0.0.1:8080".parse().unwrap();
  ///
  ///     let socket = TcpSocket::new_v4()?;
  ///     socket.bind(addr)?;
  ///
  ///     let listener = socket.listen(1024)?;
  /// # drop(listener);
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<void> bind({required SocketAddr addr});

  /// Establishes a TCP connection with a peer at the specified socket address.
  ///
  /// The `TcpSocket` is consumed. Once the connection is established, a
  /// connected [`TcpStream`] is returned. If the connection fails, the
  /// encountered error is returned.
  ///
  /// [`TcpStream`]: TcpStream
  ///
  /// This calls the `connect(2)` operating-system function. Behavior is
  /// platform specific. Refer to the target platform's documentation for more
  /// details.
  ///
  /// # Examples
  ///
  /// Connecting to a peer.
  ///
  /// ```no_run
  /// use tokio::net::TcpSocket;
  ///
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     let addr = "127.0.0.1:8080".parse().unwrap();
  ///
  ///     let socket = TcpSocket::new_v4()?;
  ///     let stream = socket.connect(addr).await?;
  /// # drop(stream);
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<TcpStream> connect({required SocketAddr addr});

  /// Converts a [`std::net::TcpStream`] into a `TcpSocket`. The provided
  /// socket must not have been connected prior to calling this function. This
  /// function is typically used together with crates such as [`socket2`] to
  /// configure socket options that are not available on `TcpSocket`.
  ///
  /// [`std::net::TcpStream`]: struct@std::net::TcpStream
  /// [`socket2`]: https://docs.rs/socket2/
  ///
  /// # Notes
  ///
  /// The caller is responsible for ensuring that the socket is in
  /// non-blocking mode. Otherwise all I/O operations on the socket
  /// will block the thread, which will cause unexpected behavior.
  /// Non-blocking mode can be set using [`set_nonblocking`].
  ///
  /// [`set_nonblocking`]: std::net::TcpStream::set_nonblocking
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio::net::TcpSocket;
  /// use socket2::{Domain, Socket, Type};
  ///
  /// #[tokio::main]
  /// async fn main() -> std::io::Result<()> {
  ///     let socket2_socket = Socket::new(Domain::IPV4, Type::STREAM, None)?;
  ///     socket2_socket.set_nonblocking(true)?;
  ///
  ///     let socket = TcpSocket::from_std_stream(socket2_socket.into());
  ///
  ///     Ok(())
  /// }
  /// ```
  static Future<TcpSocket> fromStdStream({required TcpStream stdStream}) =>
      RustLib.instance.api.tokioNetTcpSocketFromStdStream(stdStream: stdStream);

  /// Gets the value of the `SO_KEEPALIVE` option on this socket.
  Future<bool> keepalive();

  /// Reads the linger duration for this socket by getting the `SO_LINGER`
  /// option.
  ///
  /// For more information about this option, see [`set_linger`].
  ///
  /// [`set_linger`]: TcpSocket::set_linger
  Future<Duration?> linger();

  /// Converts the socket into a `TcpListener`.
  ///
  /// `backlog` defines the maximum number of pending connections are queued
  /// by the operating system at any given time. Connection are removed from
  /// the queue with [`TcpListener::accept`]. When the queue is full, the
  /// operating-system will start rejecting connections.
  ///
  /// [`TcpListener::accept`]: TcpListener::accept
  ///
  /// This calls the `listen(2)` operating-system function, marking the socket
  /// as a passive socket. Behavior is platform specific. Refer to the target
  /// platform's documentation for more details.
  ///
  /// # Examples
  ///
  /// Create a `TcpListener`.
  ///
  /// ```no_run
  /// use tokio::net::TcpSocket;
  ///
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     let addr = "127.0.0.1:8080".parse().unwrap();
  ///
  ///     let socket = TcpSocket::new_v4()?;
  ///     socket.bind(addr)?;
  ///
  ///     let listener = socket.listen(1024)?;
  /// # drop(listener);
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<TcpListener> listen({required int backlog});

  /// Gets the local address of this socket.
  ///
  /// Will fail on windows if called before `bind`.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::TcpSocket;
  ///
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     let addr = "127.0.0.1:8080".parse().unwrap();
  ///
  ///     let socket = TcpSocket::new_v4()?;
  ///     socket.bind(addr)?;
  ///     assert_eq!(socket.local_addr().unwrap().to_string(), "127.0.0.1:8080");
  ///     let listener = socket.listen(1024)?;
  ///     Ok(())
  /// }
  /// ```
  Future<SocketAddr> localAddr();

  /// Creates a new socket configured for IPv4.
  ///
  /// Calls `socket(2)` with `AF_INET` and `SOCK_STREAM`.
  ///
  /// # Returns
  ///
  /// On success, the newly created `TcpSocket` is returned. If an error is
  /// encountered, it is returned instead.
  ///
  /// # Examples
  ///
  /// Create a new IPv4 socket and start listening.
  ///
  /// ```no_run
  /// use tokio::net::TcpSocket;
  ///
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     let addr = "127.0.0.1:8080".parse().unwrap();
  ///     let socket = TcpSocket::new_v4()?;
  ///     socket.bind(addr)?;
  ///
  ///     let listener = socket.listen(128)?;
  /// # drop(listener);
  ///     Ok(())
  /// }
  /// ```
  static Future<TcpSocket> newV4() =>
      RustLib.instance.api.tokioNetTcpSocketNewV4();

  /// Creates a new socket configured for IPv6.
  ///
  /// Calls `socket(2)` with `AF_INET6` and `SOCK_STREAM`.
  ///
  /// # Returns
  ///
  /// On success, the newly created `TcpSocket` is returned. If an error is
  /// encountered, it is returned instead.
  ///
  /// # Examples
  ///
  /// Create a new IPv6 socket and start listening.
  ///
  /// ```no_run
  /// use tokio::net::TcpSocket;
  ///
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     let addr = "[::1]:8080".parse().unwrap();
  ///     let socket = TcpSocket::new_v6()?;
  ///     socket.bind(addr)?;
  ///
  ///     let listener = socket.listen(128)?;
  /// # drop(listener);
  ///     Ok(())
  /// }
  /// ```
  static Future<TcpSocket> newV6() =>
      RustLib.instance.api.tokioNetTcpSocketNewV6();

  /// Gets the value of the `TCP_NODELAY` option on this socket.
  ///
  /// For more information about this option, see [`set_nodelay`].
  ///
  /// [`set_nodelay`]: TcpSocket::set_nodelay
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::TcpSocket;
  ///
  /// # async fn dox() -> Result<(), Box<dyn std::error::Error>> {
  /// let stream = TcpSocket::new_v4()?;
  ///
  /// stream.set_nodelay(true)?;
  /// # Ok(())
  /// # }
  /// ```
  Future<bool> nodelay();

  /// Returns the size of the TCP receive buffer for this socket.
  ///
  /// On most operating systems, this is the value of the `SO_RCVBUF` socket
  /// option.
  ///
  /// Note that if [`set_recv_buffer_size`] has been called on this socket
  /// previously, the value returned by this function may not be the same as
  /// the argument provided to `set_send_buffer_size`. This is for the
  /// following reasons:
  ///
  /// * Most operating systems have minimum and maximum allowed sizes for the
  ///   receive buffer, and will clamp the provided value if it is below the
  ///   minimum or above the maximum. The minimum and maximum buffer sizes are
  ///   OS-dependent.
  /// * Linux will double the buffer size to account for internal bookkeeping
  ///   data, and returns the doubled value from `getsockopt(2)`. As per `man
  ///   7 socket`:
  ///   > Sets or gets the maximum socket send buffer in bytes. The
  ///   > kernel doubles this value (to allow space for bookkeeping
  ///   > overhead) when it is set using `setsockopt(2)`, and this doubled
  ///   > value is returned by `getsockopt(2)`.
  ///
  /// [`set_recv_buffer_size`]: #method.set_recv_buffer_size
  Future<int> recvBufferSize();

  /// Retrieves the value set for `SO_REUSEADDR` on this socket.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::TcpSocket;
  ///
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     let addr = "127.0.0.1:8080".parse().unwrap();
  ///
  ///     let socket = TcpSocket::new_v4()?;
  ///     socket.set_reuseaddr(true)?;
  ///     assert!(socket.reuseaddr().unwrap());
  ///     socket.bind(addr)?;
  ///
  ///     let listener = socket.listen(1024)?;
  ///     Ok(())
  /// }
  /// ```
  Future<bool> reuseaddr();

  /// Returns the size of the TCP send buffer for this socket.
  ///
  /// On most operating systems, this is the value of the `SO_SNDBUF` socket
  /// option.
  ///
  /// Note that if [`set_send_buffer_size`] has been called on this socket
  /// previously, the value returned by this function may not be the same as
  /// the argument provided to `set_send_buffer_size`. This is for the
  /// following reasons:
  ///
  /// * Most operating systems have minimum and maximum allowed sizes for the
  ///   send buffer, and will clamp the provided value if it is below the
  ///   minimum or above the maximum. The minimum and maximum buffer sizes are
  ///   OS-dependent.
  /// * Linux will double the buffer size to account for internal bookkeeping
  ///   data, and returns the doubled value from `getsockopt(2)`. As per `man
  ///   7 socket`:
  ///   > Sets or gets the maximum socket send buffer in bytes. The
  ///   > kernel doubles this value (to allow space for bookkeeping
  ///   > overhead) when it is set using `setsockopt(2)`, and this doubled
  ///   > value is returned by `getsockopt(2)`.
  ///
  /// [`set_send_buffer_size`]: #method.set_send_buffer_size
  Future<int> sendBufferSize();

  /// Sets value for the `SO_KEEPALIVE` option on this socket.
  Future<void> setKeepalive({required bool keepalive});

  /// Sets the linger duration of this socket by setting the `SO_LINGER` option.
  ///
  /// This option controls the action taken when a stream has unsent messages and the stream is
  /// closed. If `SO_LINGER` is set, the system shall block the process until it can transmit the
  /// data or until the time expires.
  ///
  /// If `SO_LINGER` is not specified, and the socket is closed, the system handles the call in a
  /// way that allows the process to continue as quickly as possible.
  Future<void> setLinger({Duration? dur});

  /// Sets the value of the `TCP_NODELAY` option on this socket.
  ///
  /// If set, this option disables the Nagle algorithm. This means that segments are always
  /// sent as soon as possible, even if there is only a small amount of data. When not set,
  /// data is buffered until there is a sufficient amount to send out, thereby avoiding
  /// the frequent sending of small packets.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::TcpSocket;
  ///
  /// # async fn dox() -> Result<(), Box<dyn std::error::Error>> {
  /// let socket = TcpSocket::new_v4()?;
  ///
  /// println!("{:?}", socket.nodelay()?);
  /// # Ok(())
  /// # }
  /// ```
  Future<void> setNodelay({required bool nodelay});

  /// Sets the size of the TCP receive buffer on this socket.
  ///
  /// On most operating systems, this sets the `SO_RCVBUF` socket option.
  Future<void> setRecvBufferSize({required int size});

  /// Allows the socket to bind to an in-use address.
  ///
  /// Behavior is platform specific. Refer to the target platform's
  /// documentation for more details.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::TcpSocket;
  ///
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     let addr = "127.0.0.1:8080".parse().unwrap();
  ///
  ///     let socket = TcpSocket::new_v4()?;
  ///     socket.set_reuseaddr(true)?;
  ///     socket.bind(addr)?;
  ///
  ///     let listener = socket.listen(1024)?;
  /// # drop(listener);
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<void> setReuseaddr({required bool reuseaddr});

  /// Sets the size of the TCP send buffer on this socket.
  ///
  /// On most operating systems, this sets the `SO_SNDBUF` socket option.
  Future<void> setSendBufferSize({required int size});

  /// Sets the value for the `IP_TOS` option on this socket.
  ///
  /// This value sets the type-of-service field that is used in every packet
  /// sent from this socket.
  ///
  /// **NOTE:** On Windows, `IP_TOS` is only supported on [Windows 8+ or
  /// Windows Server 2012+.](https://docs.microsoft.com/en-us/windows/win32/winsock/ipproto-ip-socket-options)
  Future<void> setTos({required int tos});

  /// Returns the value of the `SO_ERROR` option.
  Future<Error?> takeError();

  /// Gets the value of the `IP_TOS` option for this socket.
  ///
  /// For more information about this option, see [`set_tos`].
  ///
  /// **NOTE:** On Windows, `IP_TOS` is only supported on [Windows 8+ or
  /// Windows Server 2012+.](https://docs.microsoft.com/en-us/windows/win32/winsock/ipproto-ip-socket-options)
  ///
  /// [`set_tos`]: Self::set_tos
  Future<int> tos();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TcpStream>>
abstract class TcpStream implements RustOpaqueInterface {
  /// Creates new `TcpStream` from a `std::net::TcpStream`.
  ///
  /// This function is intended to be used to wrap a TCP stream from the
  /// standard library in the Tokio equivalent.
  ///
  /// # Notes
  ///
  /// The caller is responsible for ensuring that the stream is in
  /// non-blocking mode. Otherwise all I/O operations on the stream
  /// will block the thread, which will cause unexpected behavior.
  /// Non-blocking mode can be set using [`set_nonblocking`].
  ///
  /// [`set_nonblocking`]: std::net::TcpStream::set_nonblocking
  ///
  /// # Examples
  ///
  /// ```rust,no_run
  /// use std::error::Error;
  /// use tokio::net::TcpStream;
  ///
  /// #[tokio::main]
  /// async fn main() -> Result<(), Box<dyn Error>> {
  ///     let std_stream = std::net::TcpStream::connect("127.0.0.1:34254")?;
  ///     std_stream.set_nonblocking(true)?;
  ///     let stream = TcpStream::from_std(std_stream)?;
  ///     Ok(())
  /// }
  /// ```
  ///
  /// # Panics
  ///
  /// This function panics if it is not called from within a runtime with
  /// IO enabled.
  ///
  /// The runtime is usually set implicitly when this function is called
  /// from a future driven by a tokio runtime, otherwise runtime can be set
  /// explicitly with [`Runtime::enter`](crate::runtime::Runtime::enter) function.
  static Future<TcpStream> fromStd({required TcpStream stream}) =>
      RustLib.instance.api.tokioNetTcpStreamFromStd(stream: stream);

  /// Splits a `TcpStream` into a read half and a write half, which can be used
  /// to read and write the stream concurrently.
  ///
  /// Unlike [`split`], the owned halves can be moved to separate tasks, however
  /// this comes at the cost of a heap allocation.
  ///
  /// **Note:** Dropping the write half will shut down the write half of the TCP
  /// stream. This is equivalent to calling [`shutdown()`] on the `TcpStream`.
  ///
  /// [`split`]: TcpStream::split()
  /// [`shutdown()`]: fn@crate::io::AsyncWriteExt::shutdown
  Future<(OwnedReadHalf, OwnedWriteHalf)> intoSplit();

  /// Turns a [`tokio::net::TcpStream`] into a [`std::net::TcpStream`].
  ///
  /// The returned [`std::net::TcpStream`] will have nonblocking mode set as `true`.
  /// Use [`set_nonblocking`] to change the blocking mode if needed.
  ///
  /// # Examples
  ///
  /// ```
  /// use std::error::Error;
  /// use std::io::Read;
  /// use tokio::net::TcpListener;
  /// # use tokio::net::TcpStream;
  /// # use tokio::io::AsyncWriteExt;
  ///
  /// #[tokio::main]
  /// async fn main() -> Result<(), Box<dyn Error>> {
  ///     let mut data = [0u8; 12];
  /// #   if false {
  ///     let listener = TcpListener::bind("127.0.0.1:34254").await?;
  /// #   }
  /// #   let listener = TcpListener::bind("127.0.0.1:0").await?;
  /// #   let addr = listener.local_addr().unwrap();
  /// #   let handle = tokio::spawn(async move {
  /// #       let mut stream: TcpStream = TcpStream::connect(addr).await.unwrap();
  /// #       stream.write_all(b"Hello world!").await.unwrap();
  /// #   });
  ///     let (tokio_tcp_stream, _) = listener.accept().await?;
  ///     let mut std_tcp_stream = tokio_tcp_stream.into_std()?;
  /// #   handle.await.expect("The task being joined has panicked");
  ///     std_tcp_stream.set_nonblocking(false)?;
  ///     std_tcp_stream.read_exact(&mut data)?;
  /// #   assert_eq!(b"Hello world!", &data);
  ///     Ok(())
  /// }
  /// ```
  /// [`tokio::net::TcpStream`]: TcpStream
  /// [`std::net::TcpStream`]: std::net::TcpStream
  /// [`set_nonblocking`]: fn@std::net::TcpStream::set_nonblocking
  Future<TcpStream> intoStd();

  /// Reads the linger duration for this socket by getting the `SO_LINGER`
  /// option.
  ///
  /// For more information about this option, see [`set_linger`].
  ///
  /// [`set_linger`]: TcpStream::set_linger
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::TcpStream;
  ///
  /// # async fn dox() -> Result<(), Box<dyn std::error::Error>> {
  /// let stream = TcpStream::connect("127.0.0.1:8080").await?;
  ///
  /// println!("{:?}", stream.linger()?);
  /// # Ok(())
  /// # }
  /// ```
  Future<Duration?> linger();

  /// Returns the local address that this stream is bound to.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::TcpStream;
  ///
  /// # async fn dox() -> Result<(), Box<dyn std::error::Error>> {
  /// let stream = TcpStream::connect("127.0.0.1:8080").await?;
  ///
  /// println!("{:?}", stream.local_addr()?);
  /// # Ok(())
  /// # }
  /// ```
  Future<SocketAddr> localAddr();

  /// Gets the value of the `TCP_NODELAY` option on this socket.
  ///
  /// For more information about this option, see [`set_nodelay`].
  ///
  /// [`set_nodelay`]: TcpStream::set_nodelay
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::TcpStream;
  ///
  /// # async fn dox() -> Result<(), Box<dyn std::error::Error>> {
  /// let stream = TcpStream::connect("127.0.0.1:8080").await?;
  ///
  /// println!("{:?}", stream.nodelay()?);
  /// # Ok(())
  /// # }
  /// ```
  Future<bool> nodelay();

  /// Receives data on the socket from the remote address to which it is
  /// connected, without removing that data from the queue. On success,
  /// returns the number of bytes peeked.
  ///
  /// Successive calls return the same data. This is accomplished by passing
  /// `MSG_PEEK` as a flag to the underlying `recv` system call.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::TcpStream;
  /// use tokio::io::AsyncReadExt;
  /// use std::error::Error;
  ///
  /// #[tokio::main]
  /// async fn main() -> Result<(), Box<dyn Error>> {
  ///     // Connect to a peer
  ///     let mut stream = TcpStream::connect("127.0.0.1:8080").await?;
  ///
  ///     let mut b1 = [0; 10];
  ///     let mut b2 = [0; 10];
  ///
  ///     // Peek at the data
  ///     let n = stream.peek(&mut b1).await?;
  ///
  ///     // Read the data
  ///     assert_eq!(n, stream.read(&mut b2[..n]).await?);
  ///     assert_eq!(&b1[..n], &b2[..n]);
  ///
  ///     Ok(())
  /// }
  /// ```
  ///
  /// The [`read`] method is defined on the [`AsyncReadExt`] trait.
  ///
  /// [`read`]: fn@crate::io::AsyncReadExt::read
  /// [`AsyncReadExt`]: trait@crate::io::AsyncReadExt
  Future<BigInt> peek({required U8 buf});

  /// Returns the remote address that this stream is connected to.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::TcpStream;
  ///
  /// # async fn dox() -> Result<(), Box<dyn std::error::Error>> {
  /// let stream = TcpStream::connect("127.0.0.1:8080").await?;
  ///
  /// println!("{:?}", stream.peer_addr()?);
  /// # Ok(())
  /// # }
  /// ```
  Future<SocketAddr> peerAddr();

  /// Attempts to receive data on the socket, without removing that data from
  /// the queue, registering the current task for wakeup if data is not yet
  /// available.
  ///
  /// Note that on multiple calls to `poll_peek`, `poll_read` or
  /// `poll_read_ready`, only the `Waker` from the `Context` passed to the
  /// most recent call is scheduled to receive a wakeup. (However,
  /// `poll_write` retains a second, independent waker.)
  ///
  /// # Return value
  ///
  /// The function returns:
  ///
  /// * `Poll::Pending` if data is not yet available.
  /// * `Poll::Ready(Ok(n))` if data is available. `n` is the number of bytes peeked.
  /// * `Poll::Ready(Err(e))` if an error is encountered.
  ///
  /// # Errors
  ///
  /// This function may encounter any standard I/O error except `WouldBlock`.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::io::{self, ReadBuf};
  /// use tokio::net::TcpStream;
  ///
  /// use futures::future::poll_fn;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     let stream = TcpStream::connect("127.0.0.1:8000").await?;
  ///     let mut buf = [0; 10];
  ///     let mut buf = ReadBuf::new(&mut buf);
  ///
  ///     poll_fn(|cx| {
  ///         stream.poll_peek(cx, &mut buf)
  ///     }).await?;
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<PollResultUsize> pollPeek({required Context cx, required ReadBuf buf});

  /// Polls for read readiness.
  ///
  /// If the tcp stream is not currently ready for reading, this method will
  /// store a clone of the `Waker` from the provided `Context`. When the tcp
  /// stream becomes ready for reading, `Waker::wake` will be called on the
  /// waker.
  ///
  /// Note that on multiple calls to `poll_read_ready`, `poll_read` or
  /// `poll_peek`, only the `Waker` from the `Context` passed to the most
  /// recent call is scheduled to receive a wakeup. (However,
  /// `poll_write_ready` retains a second, independent waker.)
  ///
  /// This function is intended for cases where creating and pinning a future
  /// via [`readable`] is not feasible. Where possible, using [`readable`] is
  /// preferred, as this supports polling from multiple tasks at once.
  ///
  /// # Return value
  ///
  /// The function returns:
  ///
  /// * `Poll::Pending` if the tcp stream is not ready for reading.
  /// * `Poll::Ready(Ok(()))` if the tcp stream is ready for reading.
  /// * `Poll::Ready(Err(e))` if an error is encountered.
  ///
  /// # Errors
  ///
  /// This function may encounter any standard I/O error except `WouldBlock`.
  ///
  /// [`readable`]: method@Self::readable
  Future<PollResult> pollReadReady({required Context cx});

  /// Polls for write readiness.
  ///
  /// If the tcp stream is not currently ready for writing, this method will
  /// store a clone of the `Waker` from the provided `Context`. When the tcp
  /// stream becomes ready for writing, `Waker::wake` will be called on the
  /// waker.
  ///
  /// Note that on multiple calls to `poll_write_ready` or `poll_write`, only
  /// the `Waker` from the `Context` passed to the most recent call is
  /// scheduled to receive a wakeup. (However, `poll_read_ready` retains a
  /// second, independent waker.)
  ///
  /// This function is intended for cases where creating and pinning a future
  /// via [`writable`] is not feasible. Where possible, using [`writable`] is
  /// preferred, as this supports polling from multiple tasks at once.
  ///
  /// # Return value
  ///
  /// The function returns:
  ///
  /// * `Poll::Pending` if the tcp stream is not ready for writing.
  /// * `Poll::Ready(Ok(()))` if the tcp stream is ready for writing.
  /// * `Poll::Ready(Err(e))` if an error is encountered.
  ///
  /// # Errors
  ///
  /// This function may encounter any standard I/O error except `WouldBlock`.
  ///
  /// [`writable`]: method@Self::writable
  Future<PollResult> pollWriteReady({required Context cx});

  /// Waits for the socket to become readable.
  ///
  /// This function is equivalent to `ready(Interest::READABLE)` and is usually
  /// paired with `try_read()`.
  ///
  /// # Cancel safety
  ///
  /// This method is cancel safe. Once a readiness event occurs, the method
  /// will continue to return immediately until the readiness event is
  /// consumed by an attempt to read that fails with `WouldBlock` or
  /// `Poll::Pending`.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::TcpStream;
  /// use std::error::Error;
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> Result<(), Box<dyn Error>> {
  ///     // Connect to a peer
  ///     let stream = TcpStream::connect("127.0.0.1:8080").await?;
  ///
  ///     let mut msg = vec![0; 1024];
  ///
  ///     loop {
  ///         // Wait for the socket to be readable
  ///         stream.readable().await?;
  ///
  ///         // Try to read data, this may still fail with `WouldBlock`
  ///         // if the readiness event is a false positive.
  ///         match stream.try_read(&mut msg) {
  ///             Ok(n) => {
  ///                 msg.truncate(n);
  ///                 break;
  ///             }
  ///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                 continue;
  ///             }
  ///             Err(e) => {
  ///                 return Err(e.into());
  ///             }
  ///         }
  ///     }
  ///
  ///     println!("GOT = {:?}", msg);
  ///     Ok(())
  /// }
  /// ```
  Future<void> readable();

  /// Waits for any of the requested ready states.
  ///
  /// This function is usually paired with `try_read()` or `try_write()`. It
  /// can be used to concurrently read / write to the same socket on a single
  /// task without splitting the socket.
  ///
  /// The function may complete without the socket being ready. This is a
  /// false-positive and attempting an operation will return with
  /// `io::ErrorKind::WouldBlock`. The function can also return with an empty
  /// [`Ready`] set, so you should always check the returned value and possibly
  /// wait again if the requested states are not set.
  ///
  /// # Cancel safety
  ///
  /// This method is cancel safe. Once a readiness event occurs, the method
  /// will continue to return immediately until the readiness event is
  /// consumed by an attempt to read or write that fails with `WouldBlock` or
  /// `Poll::Pending`.
  ///
  /// # Examples
  ///
  /// Concurrently read and write to the stream on the same task without
  /// splitting.
  ///
  /// ```no_run
  /// use tokio::io::Interest;
  /// use tokio::net::TcpStream;
  /// use std::error::Error;
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> Result<(), Box<dyn Error>> {
  ///     let stream = TcpStream::connect("127.0.0.1:8080").await?;
  ///
  ///     loop {
  ///         let ready = stream.ready(Interest::READABLE | Interest::WRITABLE).await?;
  ///
  ///         if ready.is_readable() {
  ///             let mut data = vec![0; 1024];
  ///             // Try to read data, this may still fail with `WouldBlock`
  ///             // if the readiness event is a false positive.
  ///             match stream.try_read(&mut data) {
  ///                 Ok(n) => {
  ///                     println!("read {} bytes", n);
  ///                 }
  ///                 Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                     continue;
  ///                 }
  ///                 Err(e) => {
  ///                     return Err(e.into());
  ///                 }
  ///             }
  ///
  ///         }
  ///
  ///         if ready.is_writable() {
  ///             // Try to write data, this may still fail with `WouldBlock`
  ///             // if the readiness event is a false positive.
  ///             match stream.try_write(b"hello world") {
  ///                 Ok(n) => {
  ///                     println!("write {} bytes", n);
  ///                 }
  ///                 Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                     continue
  ///                 }
  ///                 Err(e) => {
  ///                     return Err(e.into());
  ///                 }
  ///             }
  ///         }
  ///     }
  /// }
  /// ```
  Future<Ready> ready({required Interest interest});

  /// Sets the linger duration of this socket by setting the `SO_LINGER` option.
  ///
  /// This option controls the action taken when a stream has unsent messages and the stream is
  /// closed. If `SO_LINGER` is set, the system shall block the process until it can transmit the
  /// data or until the time expires.
  ///
  /// If `SO_LINGER` is not specified, and the stream is closed, the system handles the call in a
  /// way that allows the process to continue as quickly as possible.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::TcpStream;
  ///
  /// # async fn dox() -> Result<(), Box<dyn std::error::Error>> {
  /// let stream = TcpStream::connect("127.0.0.1:8080").await?;
  ///
  /// stream.set_linger(None)?;
  /// # Ok(())
  /// # }
  /// ```
  Future<void> setLinger({Duration? dur});

  /// Sets the value of the `TCP_NODELAY` option on this socket.
  ///
  /// If set, this option disables the Nagle algorithm. This means that
  /// segments are always sent as soon as possible, even if there is only a
  /// small amount of data. When not set, data is buffered until there is a
  /// sufficient amount to send out, thereby avoiding the frequent sending of
  /// small packets.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::TcpStream;
  ///
  /// # async fn dox() -> Result<(), Box<dyn std::error::Error>> {
  /// let stream = TcpStream::connect("127.0.0.1:8080").await?;
  ///
  /// stream.set_nodelay(true)?;
  /// # Ok(())
  /// # }
  /// ```
  Future<void> setNodelay({required bool nodelay});

  /// Sets the value for the `IP_TTL` option on this socket.
  ///
  /// This value sets the time-to-live field that is used in every packet sent
  /// from this socket.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::TcpStream;
  ///
  /// # async fn dox() -> Result<(), Box<dyn std::error::Error>> {
  /// let stream = TcpStream::connect("127.0.0.1:8080").await?;
  ///
  /// stream.set_ttl(123)?;
  /// # Ok(())
  /// # }
  /// ```
  Future<void> setTtl({required int ttl});

  /// Returns the value of the `SO_ERROR` option.
  Future<Error?> takeError();

  /// Tries to read data from the stream into the provided buffer, returning how
  /// many bytes were read.
  ///
  /// Receives any pending data from the socket but does not wait for new data
  /// to arrive. On success, returns the number of bytes read. Because
  /// `try_read()` is non-blocking, the buffer does not have to be stored by
  /// the async task and can exist entirely on the stack.
  ///
  /// Usually, [`readable()`] or [`ready()`] is used with this function.
  ///
  /// [`readable()`]: TcpStream::readable()
  /// [`ready()`]: TcpStream::ready()
  ///
  /// # Return
  ///
  /// If data is successfully read, `Ok(n)` is returned, where `n` is the
  /// number of bytes read. If `n` is `0`, then it can indicate one of two scenarios:
  ///
  /// 1. The stream's read half is closed and will no longer yield data.
  /// 2. The specified buffer was 0 bytes in length.
  ///
  /// If the stream is not ready to read data,
  /// `Err(io::ErrorKind::WouldBlock)` is returned.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::TcpStream;
  /// use std::error::Error;
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> Result<(), Box<dyn Error>> {
  ///     // Connect to a peer
  ///     let stream = TcpStream::connect("127.0.0.1:8080").await?;
  ///
  ///     loop {
  ///         // Wait for the socket to be readable
  ///         stream.readable().await?;
  ///
  ///         // Creating the buffer **after** the `await` prevents it from
  ///         // being stored in the async task.
  ///         let mut buf = [0; 4096];
  ///
  ///         // Try to read data, this may still fail with `WouldBlock`
  ///         // if the readiness event is a false positive.
  ///         match stream.try_read(&mut buf) {
  ///             Ok(0) => break,
  ///             Ok(n) => {
  ///                 println!("read {} bytes", n);
  ///             }
  ///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                 continue;
  ///             }
  ///             Err(e) => {
  ///                 return Err(e.into());
  ///             }
  ///         }
  ///     }
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<BigInt> tryRead({required U8 buf});

  /// Tries to read data from the stream into the provided buffers, returning
  /// how many bytes were read.
  ///
  /// Data is copied to fill each buffer in order, with the final buffer
  /// written to possibly being only partially filled. This method behaves
  /// equivalently to a single call to [`try_read()`] with concatenated
  /// buffers.
  ///
  /// Receives any pending data from the socket but does not wait for new data
  /// to arrive. On success, returns the number of bytes read. Because
  /// `try_read_vectored()` is non-blocking, the buffer does not have to be
  /// stored by the async task and can exist entirely on the stack.
  ///
  /// Usually, [`readable()`] or [`ready()`] is used with this function.
  ///
  /// [`try_read()`]: TcpStream::try_read()
  /// [`readable()`]: TcpStream::readable()
  /// [`ready()`]: TcpStream::ready()
  ///
  /// # Return
  ///
  /// If data is successfully read, `Ok(n)` is returned, where `n` is the
  /// number of bytes read. `Ok(0)` indicates the stream's read half is closed
  /// and will no longer yield data. If the stream is not ready to read data
  /// `Err(io::ErrorKind::WouldBlock)` is returned.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::TcpStream;
  /// use std::error::Error;
  /// use std::io::{self, IoSliceMut};
  ///
  /// #[tokio::main]
  /// async fn main() -> Result<(), Box<dyn Error>> {
  ///     // Connect to a peer
  ///     let stream = TcpStream::connect("127.0.0.1:8080").await?;
  ///
  ///     loop {
  ///         // Wait for the socket to be readable
  ///         stream.readable().await?;
  ///
  ///         // Creating the buffer **after** the `await` prevents it from
  ///         // being stored in the async task.
  ///         let mut buf_a = [0; 512];
  ///         let mut buf_b = [0; 1024];
  ///         let mut bufs = [
  ///             IoSliceMut::new(&mut buf_a),
  ///             IoSliceMut::new(&mut buf_b),
  ///         ];
  ///
  ///         // Try to read data, this may still fail with `WouldBlock`
  ///         // if the readiness event is a false positive.
  ///         match stream.try_read_vectored(&mut bufs) {
  ///             Ok(0) => break,
  ///             Ok(n) => {
  ///                 println!("read {} bytes", n);
  ///             }
  ///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                 continue;
  ///             }
  ///             Err(e) => {
  ///                 return Err(e.into());
  ///             }
  ///         }
  ///     }
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<BigInt> tryReadVectored({required IoSliceMut bufs});

  /// Try to write a buffer to the stream, returning how many bytes were
  /// written.
  ///
  /// The function will attempt to write the entire contents of `buf`, but
  /// only part of the buffer may be written.
  ///
  /// This function is usually paired with `writable()`.
  ///
  /// # Return
  ///
  /// If data is successfully written, `Ok(n)` is returned, where `n` is the
  /// number of bytes written. If the stream is not ready to write data,
  /// `Err(io::ErrorKind::WouldBlock)` is returned.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::TcpStream;
  /// use std::error::Error;
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> Result<(), Box<dyn Error>> {
  ///     // Connect to a peer
  ///     let stream = TcpStream::connect("127.0.0.1:8080").await?;
  ///
  ///     loop {
  ///         // Wait for the socket to be writable
  ///         stream.writable().await?;
  ///
  ///         // Try to write data, this may still fail with `WouldBlock`
  ///         // if the readiness event is a false positive.
  ///         match stream.try_write(b"hello world") {
  ///             Ok(n) => {
  ///                 break;
  ///             }
  ///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                 continue;
  ///             }
  ///             Err(e) => {
  ///                 return Err(e.into());
  ///             }
  ///         }
  ///     }
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<BigInt> tryWrite({required List<int> buf});

  /// Tries to write several buffers to the stream, returning how many bytes
  /// were written.
  ///
  /// Data is written from each buffer in order, with the final buffer read
  /// from possible being only partially consumed. This method behaves
  /// equivalently to a single call to [`try_write()`] with concatenated
  /// buffers.
  ///
  /// This function is usually paired with `writable()`.
  ///
  /// [`try_write()`]: TcpStream::try_write()
  ///
  /// # Return
  ///
  /// If data is successfully written, `Ok(n)` is returned, where `n` is the
  /// number of bytes written. If the stream is not ready to write data,
  /// `Err(io::ErrorKind::WouldBlock)` is returned.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::TcpStream;
  /// use std::error::Error;
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> Result<(), Box<dyn Error>> {
  ///     // Connect to a peer
  ///     let stream = TcpStream::connect("127.0.0.1:8080").await?;
  ///
  ///     let bufs = [io::IoSlice::new(b"hello "), io::IoSlice::new(b"world")];
  ///
  ///     loop {
  ///         // Wait for the socket to be writable
  ///         stream.writable().await?;
  ///
  ///         // Try to write data, this may still fail with `WouldBlock`
  ///         // if the readiness event is a false positive.
  ///         match stream.try_write_vectored(&bufs) {
  ///             Ok(n) => {
  ///                 break;
  ///             }
  ///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                 continue;
  ///             }
  ///             Err(e) => {
  ///                 return Err(e.into());
  ///             }
  ///         }
  ///     }
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<BigInt> tryWriteVectored({required List<IoSlice> bufs});

  /// Gets the value of the `IP_TTL` option for this socket.
  ///
  /// For more information about this option, see [`set_ttl`].
  ///
  /// [`set_ttl`]: TcpStream::set_ttl
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::TcpStream;
  ///
  /// # async fn dox() -> Result<(), Box<dyn std::error::Error>> {
  /// let stream = TcpStream::connect("127.0.0.1:8080").await?;
  ///
  /// println!("{:?}", stream.ttl()?);
  /// # Ok(())
  /// # }
  /// ```
  Future<int> ttl();

  /// Waits for the socket to become writable.
  ///
  /// This function is equivalent to `ready(Interest::WRITABLE)` and is usually
  /// paired with `try_write()`.
  ///
  /// # Cancel safety
  ///
  /// This method is cancel safe. Once a readiness event occurs, the method
  /// will continue to return immediately until the readiness event is
  /// consumed by an attempt to write that fails with `WouldBlock` or
  /// `Poll::Pending`.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::TcpStream;
  /// use std::error::Error;
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> Result<(), Box<dyn Error>> {
  ///     // Connect to a peer
  ///     let stream = TcpStream::connect("127.0.0.1:8080").await?;
  ///
  ///     loop {
  ///         // Wait for the socket to be writable
  ///         stream.writable().await?;
  ///
  ///         // Try to write data, this may still fail with `WouldBlock`
  ///         // if the readiness event is a false positive.
  ///         match stream.try_write(b"hello world") {
  ///             Ok(n) => {
  ///                 break;
  ///             }
  ///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                 continue;
  ///             }
  ///             Err(e) => {
  ///                 return Err(e.into());
  ///             }
  ///         }
  ///     }
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<void> writable();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UdpSocket>>
abstract class UdpSocket implements RustOpaqueInterface {
  /// Gets the value of the `SO_BROADCAST` option for this socket.
  ///
  /// For more information about this option, see [`set_broadcast`].
  ///
  /// [`set_broadcast`]: method@Self::set_broadcast
  Future<bool> broadcast();

  /// Creates new `UdpSocket` from a previously bound `std::net::UdpSocket`.
  ///
  /// This function is intended to be used to wrap a UDP socket from the
  /// standard library in the Tokio equivalent.
  ///
  /// This can be used in conjunction with `socket2`'s `Socket` interface to
  /// configure a socket before it's handed off, such as setting options like
  /// `reuse_address` or binding to multiple addresses.
  ///
  /// # Notes
  ///
  /// The caller is responsible for ensuring that the socket is in
  /// non-blocking mode. Otherwise all I/O operations on the socket
  /// will block the thread, which will cause unexpected behavior.
  /// Non-blocking mode can be set using [`set_nonblocking`].
  ///
  /// [`set_nonblocking`]: std::net::UdpSocket::set_nonblocking
  ///
  /// # Panics
  ///
  /// This function panics if thread-local runtime is not set.
  ///
  /// The runtime is usually set implicitly when this function is called
  /// from a future driven by a tokio runtime, otherwise runtime can be set
  /// explicitly with [`Runtime::enter`](crate::runtime::Runtime::enter) function.
  ///
  /// # Example
  ///
  /// ```no_run
  /// use tokio::net::UdpSocket;
  /// # use std::{io, net::SocketAddr};
  ///
  /// # #[tokio::main]
  /// # async fn main() -> io::Result<()> {
  /// let addr = "0.0.0.0:8080".parse::<SocketAddr>().unwrap();
  /// let std_sock = std::net::UdpSocket::bind(addr)?;
  /// std_sock.set_nonblocking(true)?;
  /// let sock = UdpSocket::from_std(std_sock)?;
  /// // use `sock`
  /// # Ok(())
  /// # }
  /// ```
  static Future<UdpSocket> fromStd({required UdpSocket socket}) =>
      RustLib.instance.api.tokioNetUdpSocketFromStd(socket: socket);

  /// Turns a [`tokio::net::UdpSocket`] into a [`std::net::UdpSocket`].
  ///
  /// The returned [`std::net::UdpSocket`] will have nonblocking mode set as
  /// `true`.  Use [`set_nonblocking`] to change the blocking mode if needed.
  ///
  /// # Examples
  ///
  /// ```rust,no_run
  /// use std::error::Error;
  ///
  /// #[tokio::main]
  /// async fn main() -> Result<(), Box<dyn Error>> {
  ///     let tokio_socket = tokio::net::UdpSocket::bind("127.0.0.1:0").await?;
  ///     let std_socket = tokio_socket.into_std()?;
  ///     std_socket.set_nonblocking(false)?;
  ///     Ok(())
  /// }
  /// ```
  ///
  /// [`tokio::net::UdpSocket`]: UdpSocket
  /// [`std::net::UdpSocket`]: std::net::UdpSocket
  /// [`set_nonblocking`]: fn@std::net::UdpSocket::set_nonblocking
  Future<UdpSocket> intoStd();

  /// Executes an operation of the `IP_ADD_MEMBERSHIP` type.
  ///
  /// This function specifies a new multicast group for this socket to join.
  /// The address must be a valid multicast address, and `interface` is the
  /// address of the local interface with which the system should join the
  /// multicast group. If it's equal to `INADDR_ANY` then an appropriate
  /// interface is chosen by the system.
  Future<void> joinMulticastV4(
      {required Ipv4Addr multiaddr, required Ipv4Addr interface_});

  /// Executes an operation of the `IPV6_ADD_MEMBERSHIP` type.
  ///
  /// This function specifies a new multicast group for this socket to join.
  /// The address must be a valid multicast address, and `interface` is the
  /// index of the interface to join/leave (or 0 to indicate any interface).
  Future<void> joinMulticastV6(
      {required Ipv6Addr multiaddr, required int interface_});

  /// Executes an operation of the `IP_DROP_MEMBERSHIP` type.
  ///
  /// For more information about this option, see [`join_multicast_v4`].
  ///
  /// [`join_multicast_v4`]: method@Self::join_multicast_v4
  Future<void> leaveMulticastV4(
      {required Ipv4Addr multiaddr, required Ipv4Addr interface_});

  /// Executes an operation of the `IPV6_DROP_MEMBERSHIP` type.
  ///
  /// For more information about this option, see [`join_multicast_v6`].
  ///
  /// [`join_multicast_v6`]: method@Self::join_multicast_v6
  Future<void> leaveMulticastV6(
      {required Ipv6Addr multiaddr, required int interface_});

  /// Returns the local address that this socket is bound to.
  ///
  /// # Example
  ///
  /// ```no_run
  /// use tokio::net::UdpSocket;
  /// # use std::{io, net::SocketAddr};
  ///
  /// # #[tokio::main]
  /// # async fn main() -> io::Result<()> {
  /// let addr = "0.0.0.0:8080".parse::<SocketAddr>().unwrap();
  /// let sock = UdpSocket::bind(addr).await?;
  /// // the address the socket is bound to
  /// let local_addr = sock.local_addr()?;
  /// # Ok(())
  /// # }
  /// ```
  Future<SocketAddr> localAddr();

  /// Gets the value of the `IP_MULTICAST_LOOP` option for this socket.
  ///
  /// For more information about this option, see [`set_multicast_loop_v4`].
  ///
  /// [`set_multicast_loop_v4`]: method@Self::set_multicast_loop_v4
  Future<bool> multicastLoopV4();

  /// Gets the value of the `IPV6_MULTICAST_LOOP` option for this socket.
  ///
  /// For more information about this option, see [`set_multicast_loop_v6`].
  ///
  /// [`set_multicast_loop_v6`]: method@Self::set_multicast_loop_v6
  Future<bool> multicastLoopV6();

  /// Gets the value of the `IP_MULTICAST_TTL` option for this socket.
  ///
  /// For more information about this option, see [`set_multicast_ttl_v4`].
  ///
  /// [`set_multicast_ttl_v4`]: method@Self::set_multicast_ttl_v4
  Future<int> multicastTtlV4();

  /// Receives data from the socket, without removing it from the input queue.
  /// On success, returns the number of bytes read and the address from whence
  /// the data came.
  ///
  /// # Notes
  ///
  /// On Windows, if the data is larger than the buffer specified, the buffer
  /// is filled with the first part of the data, and `peek_from` returns the error
  /// `WSAEMSGSIZE(10040)`. The excess data is lost.
  /// Make sure to always use a sufficiently large buffer to hold the
  /// maximum UDP packet size, which can be up to 65536 bytes in size.
  ///
  /// MacOS will return an error if you pass a zero-sized buffer.
  ///
  /// If you're merely interested in learning the sender of the data at the head of the queue,
  /// try [`peek_sender`].
  ///
  /// Note that the socket address **cannot** be implicitly trusted, because it is relatively
  /// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].
  /// Because UDP is stateless and does not validate the origin of a packet,
  /// the attacker does not need to be able to intercept traffic in order to interfere.
  /// It is important to be aware of this when designing your application-level protocol.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::UdpSocket;
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     let socket = UdpSocket::bind("127.0.0.1:8080").await?;
  ///
  ///     let mut buf = vec![0u8; 32];
  ///     let (len, addr) = socket.peek_from(&mut buf).await?;
  ///
  ///     println!("peeked {:?} bytes from {:?}", len, addr);
  ///
  ///     Ok(())
  /// }
  /// ```
  ///
  /// [`peek_sender`]: method@Self::peek_sender
  /// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection
  Future<(BigInt, SocketAddr)> peekFrom({required U8 buf});

  /// Retrieve the sender of the data at the head of the input queue, waiting if empty.
  ///
  /// This is equivalent to calling [`peek_from`] with a zero-sized buffer,
  /// but suppresses the `WSAEMSGSIZE` error on Windows and the "invalid argument" error on macOS.
  ///
  /// Note that the socket address **cannot** be implicitly trusted, because it is relatively
  /// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].
  /// Because UDP is stateless and does not validate the origin of a packet,
  /// the attacker does not need to be able to intercept traffic in order to interfere.
  /// It is important to be aware of this when designing your application-level protocol.
  ///
  /// [`peek_from`]: method@Self::peek_from
  /// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection
  Future<SocketAddr> peekSender();

  /// Returns the socket address of the remote peer this socket was connected to.
  ///
  /// # Example
  ///
  /// ```
  /// use tokio::net::UdpSocket;
  ///
  /// # use std::{io, net::SocketAddr};
  /// # #[tokio::main]
  /// # async fn main() -> io::Result<()> {
  /// let addr = "0.0.0.0:8080".parse::<SocketAddr>().unwrap();
  /// let peer = "127.0.0.1:11100".parse::<SocketAddr>().unwrap();
  /// let sock = UdpSocket::bind(addr).await?;
  /// sock.connect(peer).await?;
  /// assert_eq!(peer, sock.peer_addr()?);
  /// #    Ok(())
  /// # }
  /// ```
  Future<SocketAddr> peerAddr();

  /// Receives data from the socket, without removing it from the input queue.
  /// On success, returns the sending address of the datagram.
  ///
  /// # Notes
  ///
  /// Note that on multiple calls to a `poll_*` method in the `recv` direction, only the
  /// `Waker` from the `Context` passed to the most recent call will be scheduled to
  /// receive a wakeup
  ///
  /// On Windows, if the data is larger than the buffer specified, the buffer
  /// is filled with the first part of the data, and peek returns the error
  /// `WSAEMSGSIZE(10040)`. The excess data is lost.
  /// Make sure to always use a sufficiently large buffer to hold the
  /// maximum UDP packet size, which can be up to 65536 bytes in size.
  ///
  /// MacOS will return an error if you pass a zero-sized buffer.
  ///
  /// If you're merely interested in learning the sender of the data at the head of the queue,
  /// try [`poll_peek_sender`].
  ///
  /// Note that the socket address **cannot** be implicitly trusted, because it is relatively
  /// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].
  /// Because UDP is stateless and does not validate the origin of a packet,
  /// the attacker does not need to be able to intercept traffic in order to interfere.
  /// It is important to be aware of this when designing your application-level protocol.
  ///
  /// # Return value
  ///
  /// The function returns:
  ///
  /// * `Poll::Pending` if the socket is not ready to read
  /// * `Poll::Ready(Ok(addr))` reads data from `addr` into `ReadBuf` if the socket is ready
  /// * `Poll::Ready(Err(e))` if an error is encountered.
  ///
  /// # Errors
  ///
  /// This function may encounter any standard I/O error except `WouldBlock`.
  ///
  /// [`poll_peek_sender`]: method@Self::poll_peek_sender
  /// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection
  Future<PollResultSocketAddr> pollPeekFrom(
      {required Context cx, required ReadBuf buf});

  /// Retrieve the sender of the data at the head of the input queue,
  /// scheduling a wakeup if empty.
  ///
  /// This is equivalent to calling [`poll_peek_from`] with a zero-sized buffer,
  /// but suppresses the `WSAEMSGSIZE` error on Windows and the "invalid argument" error on macOS.
  ///
  /// # Notes
  ///
  /// Note that on multiple calls to a `poll_*` method in the `recv` direction, only the
  /// `Waker` from the `Context` passed to the most recent call will be scheduled to
  /// receive a wakeup.
  ///
  /// Note that the socket address **cannot** be implicitly trusted, because it is relatively
  /// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].
  /// Because UDP is stateless and does not validate the origin of a packet,
  /// the attacker does not need to be able to intercept traffic in order to interfere.
  /// It is important to be aware of this when designing your application-level protocol.
  ///
  /// [`poll_peek_from`]: method@Self::poll_peek_from
  /// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection
  Future<PollResultSocketAddr> pollPeekSender({required Context cx});

  /// Attempts to receive a single datagram message on the socket from the remote
  /// address to which it is `connect`ed.
  ///
  /// The [`connect`] method will connect this socket to a remote address. This method
  /// resolves to an error if the socket is not connected.
  ///
  /// Note that on multiple calls to a `poll_*` method in the `recv` direction, only the
  /// `Waker` from the `Context` passed to the most recent call will be scheduled to
  /// receive a wakeup.
  ///
  /// # Return value
  ///
  /// The function returns:
  ///
  /// * `Poll::Pending` if the socket is not ready to read
  /// * `Poll::Ready(Ok(()))` reads data `ReadBuf` if the socket is ready
  /// * `Poll::Ready(Err(e))` if an error is encountered.
  ///
  /// # Errors
  ///
  /// This function may encounter any standard I/O error except `WouldBlock`.
  ///
  /// [`connect`]: method@Self::connect
  Future<PollResult> pollRecv({required Context cx, required ReadBuf buf});

  /// Attempts to receive a single datagram on the socket.
  ///
  /// Note that on multiple calls to a `poll_*` method in the `recv` direction, only the
  /// `Waker` from the `Context` passed to the most recent call will be scheduled to
  /// receive a wakeup.
  ///
  /// # Return value
  ///
  /// The function returns:
  ///
  /// * `Poll::Pending` if the socket is not ready to read
  /// * `Poll::Ready(Ok(addr))` reads data from `addr` into `ReadBuf` if the socket is ready
  /// * `Poll::Ready(Err(e))` if an error is encountered.
  ///
  /// # Errors
  ///
  /// This function may encounter any standard I/O error except `WouldBlock`.
  ///
  /// # Notes
  /// Note that the socket address **cannot** be implicitly trusted, because it is relatively
  /// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].
  /// Because UDP is stateless and does not validate the origin of a packet,
  /// the attacker does not need to be able to intercept traffic in order to interfere.
  /// It is important to be aware of this when designing your application-level protocol.
  ///
  /// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection
  Future<PollResultSocketAddr> pollRecvFrom(
      {required Context cx, required ReadBuf buf});

  /// Polls for read/receive readiness.
  ///
  /// If the udp stream is not currently ready for receiving, this method will
  /// store a clone of the `Waker` from the provided `Context`. When the udp
  /// socket becomes ready for reading, `Waker::wake` will be called on the
  /// waker.
  ///
  /// Note that on multiple calls to `poll_recv_ready`, `poll_recv` or
  /// `poll_peek`, only the `Waker` from the `Context` passed to the most
  /// recent call is scheduled to receive a wakeup. (However,
  /// `poll_send_ready` retains a second, independent waker.)
  ///
  /// This function is intended for cases where creating and pinning a future
  /// via [`readable`] is not feasible. Where possible, using [`readable`] is
  /// preferred, as this supports polling from multiple tasks at once.
  ///
  /// # Return value
  ///
  /// The function returns:
  ///
  /// * `Poll::Pending` if the udp stream is not ready for reading.
  /// * `Poll::Ready(Ok(()))` if the udp stream is ready for reading.
  /// * `Poll::Ready(Err(e))` if an error is encountered.
  ///
  /// # Errors
  ///
  /// This function may encounter any standard I/O error except `WouldBlock`.
  ///
  /// [`readable`]: method@Self::readable
  Future<PollResult> pollRecvReady({required Context cx});

  /// Attempts to send data on the socket to the remote address to which it
  /// was previously `connect`ed.
  ///
  /// The [`connect`] method will connect this socket to a remote address.
  /// This method will fail if the socket is not connected.
  ///
  /// Note that on multiple calls to a `poll_*` method in the send direction,
  /// only the `Waker` from the `Context` passed to the most recent call will
  /// be scheduled to receive a wakeup.
  ///
  /// # Return value
  ///
  /// The function returns:
  ///
  /// * `Poll::Pending` if the socket is not available to write
  /// * `Poll::Ready(Ok(n))` `n` is the number of bytes sent
  /// * `Poll::Ready(Err(e))` if an error is encountered.
  ///
  /// # Errors
  ///
  /// This function may encounter any standard I/O error except `WouldBlock`.
  ///
  /// [`connect`]: method@Self::connect
  Future<PollResultUsize> pollSend(
      {required Context cx, required List<int> buf});

  /// Polls for write/send readiness.
  ///
  /// If the udp stream is not currently ready for sending, this method will
  /// store a clone of the `Waker` from the provided `Context`. When the udp
  /// stream becomes ready for sending, `Waker::wake` will be called on the
  /// waker.
  ///
  /// Note that on multiple calls to `poll_send_ready` or `poll_send`, only
  /// the `Waker` from the `Context` passed to the most recent call is
  /// scheduled to receive a wakeup. (However, `poll_recv_ready` retains a
  /// second, independent waker.)
  ///
  /// This function is intended for cases where creating and pinning a future
  /// via [`writable`] is not feasible. Where possible, using [`writable`] is
  /// preferred, as this supports polling from multiple tasks at once.
  ///
  /// # Return value
  ///
  /// The function returns:
  ///
  /// * `Poll::Pending` if the udp stream is not ready for writing.
  /// * `Poll::Ready(Ok(()))` if the udp stream is ready for writing.
  /// * `Poll::Ready(Err(e))` if an error is encountered.
  ///
  /// # Errors
  ///
  /// This function may encounter any standard I/O error except `WouldBlock`.
  ///
  /// [`writable`]: method@Self::writable
  Future<PollResult> pollSendReady({required Context cx});

  /// Attempts to send data on the socket to a given address.
  ///
  /// Note that on multiple calls to a `poll_*` method in the send direction, only the
  /// `Waker` from the `Context` passed to the most recent call will be scheduled to
  /// receive a wakeup.
  ///
  /// # Return value
  ///
  /// The function returns:
  ///
  /// * `Poll::Pending` if the socket is not ready to write
  /// * `Poll::Ready(Ok(n))` `n` is the number of bytes sent.
  /// * `Poll::Ready(Err(e))` if an error is encountered.
  ///
  /// # Errors
  ///
  /// This function may encounter any standard I/O error except `WouldBlock`.
  Future<PollResultUsize> pollSendTo(
      {required Context cx,
      required List<int> buf,
      required SocketAddr target});

  /// Waits for the socket to become readable.
  ///
  /// This function is equivalent to `ready(Interest::READABLE)` and is usually
  /// paired with `try_recv()`.
  ///
  /// The function may complete without the socket being readable. This is a
  /// false-positive and attempting a `try_recv()` will return with
  /// `io::ErrorKind::WouldBlock`.
  ///
  /// # Cancel safety
  ///
  /// This method is cancel safe. Once a readiness event occurs, the method
  /// will continue to return immediately until the readiness event is
  /// consumed by an attempt to read that fails with `WouldBlock` or
  /// `Poll::Pending`.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::UdpSocket;
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     // Connect to a peer
  ///     let socket = UdpSocket::bind("127.0.0.1:8080").await?;
  ///     socket.connect("127.0.0.1:8081").await?;
  ///
  ///     loop {
  ///         // Wait for the socket to be readable
  ///         socket.readable().await?;
  ///
  ///         // The buffer is **not** included in the async task and will
  ///         // only exist on the stack.
  ///         let mut buf = [0; 1024];
  ///
  ///         // Try to recv data, this may still fail with `WouldBlock`
  ///         // if the readiness event is a false positive.
  ///         match socket.try_recv(&mut buf) {
  ///             Ok(n) => {
  ///                 println!("GOT {:?}", &buf[..n]);
  ///                 break;
  ///             }
  ///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                 continue;
  ///             }
  ///             Err(e) => {
  ///                 return Err(e);
  ///             }
  ///         }
  ///     }
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<void> readable();

  /// Waits for any of the requested ready states.
  ///
  /// This function is usually paired with `try_recv()` or `try_send()`. It
  /// can be used to concurrently `recv` / `send` to the same socket on a single
  /// task without splitting the socket.
  ///
  /// The function may complete without the socket being ready. This is a
  /// false-positive and attempting an operation will return with
  /// `io::ErrorKind::WouldBlock`. The function can also return with an empty
  /// [`Ready`] set, so you should always check the returned value and possibly
  /// wait again if the requested states are not set.
  ///
  /// # Cancel safety
  ///
  /// This method is cancel safe. Once a readiness event occurs, the method
  /// will continue to return immediately until the readiness event is
  /// consumed by an attempt to read or write that fails with `WouldBlock` or
  /// `Poll::Pending`.
  ///
  /// # Examples
  ///
  /// Concurrently receive from and send to the socket on the same task
  /// without splitting.
  ///
  /// ```no_run
  /// use tokio::io::{self, Interest};
  /// use tokio::net::UdpSocket;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     let socket = UdpSocket::bind("127.0.0.1:8080").await?;
  ///     socket.connect("127.0.0.1:8081").await?;
  ///
  ///     loop {
  ///         let ready = socket.ready(Interest::READABLE | Interest::WRITABLE).await?;
  ///
  ///         if ready.is_readable() {
  ///             // The buffer is **not** included in the async task and will only exist
  ///             // on the stack.
  ///             let mut data = [0; 1024];
  ///             match socket.try_recv(&mut data[..]) {
  ///                 Ok(n) => {
  ///                     println!("received {:?}", &data[..n]);
  ///                 }
  ///                 // False-positive, continue
  ///                 Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {}
  ///                 Err(e) => {
  ///                     return Err(e);
  ///                 }
  ///             }
  ///         }
  ///
  ///         if ready.is_writable() {
  ///             // Write some data
  ///             match socket.try_send(b"hello world") {
  ///                 Ok(n) => {
  ///                     println!("sent {} bytes", n);
  ///                 }
  ///                 // False-positive, continue
  ///                 Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {}
  ///                 Err(e) => {
  ///                     return Err(e);
  ///                 }
  ///             }
  ///         }
  ///     }
  /// }
  /// ```
  Future<Ready> ready({required Interest interest});

  /// Receives a single datagram message on the socket from the remote address
  /// to which it is connected. On success, returns the number of bytes read.
  ///
  /// The function must be called with valid byte array `buf` of sufficient
  /// size to hold the message bytes. If a message is too long to fit in the
  /// supplied buffer, excess bytes may be discarded.
  ///
  /// The [`connect`] method will connect this socket to a remote address.
  /// This method will fail if the socket is not connected.
  ///
  /// # Cancel safety
  ///
  /// This method is cancel safe. If `recv` is used as the event in a
  /// [`tokio::select!`](crate::select) statement and some other branch
  /// completes first, it is guaranteed that no messages were received on this
  /// socket.
  ///
  /// [`connect`]: method@Self::connect
  ///
  /// ```no_run
  /// use tokio::net::UdpSocket;
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     // Bind socket
  ///     let socket = UdpSocket::bind("127.0.0.1:8080").await?;
  ///     socket.connect("127.0.0.1:8081").await?;
  ///
  ///     let mut buf = vec![0; 10];
  ///     let n = socket.recv(&mut buf).await?;
  ///
  ///     println!("received {} bytes {:?}", n, &buf[..n]);
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<BigInt> recv({required U8 buf});

  /// Receives a single datagram message on the socket. On success, returns
  /// the number of bytes read and the origin.
  ///
  /// The function must be called with valid byte array `buf` of sufficient
  /// size to hold the message bytes. If a message is too long to fit in the
  /// supplied buffer, excess bytes may be discarded.
  ///
  /// # Cancel safety
  ///
  /// This method is cancel safe. If `recv_from` is used as the event in a
  /// [`tokio::select!`](crate::select) statement and some other branch
  /// completes first, it is guaranteed that no messages were received on this
  /// socket.
  ///
  /// # Example
  ///
  /// ```no_run
  /// use tokio::net::UdpSocket;
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     let socket = UdpSocket::bind("127.0.0.1:8080").await?;
  ///
  ///     let mut buf = vec![0u8; 32];
  ///     let (len, addr) = socket.recv_from(&mut buf).await?;
  ///
  ///     println!("received {:?} bytes from {:?}", len, addr);
  ///
  ///     Ok(())
  /// }
  /// ```
  ///
  /// # Notes
  /// Note that the socket address **cannot** be implicitly trusted, because it is relatively
  /// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].
  /// Because UDP is stateless and does not validate the origin of a packet,
  /// the attacker does not need to be able to intercept traffic in order to interfere.
  /// It is important to be aware of this when designing your application-level protocol.
  ///
  /// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection
  Future<(BigInt, SocketAddr)> recvFrom({required U8 buf});

  /// Sends data on the socket to the remote address that the socket is
  /// connected to.
  ///
  /// The [`connect`] method will connect this socket to a remote address.
  /// This method will fail if the socket is not connected.
  ///
  /// [`connect`]: method@Self::connect
  ///
  /// # Return
  ///
  /// On success, the number of bytes sent is returned, otherwise, the
  /// encountered error is returned.
  ///
  /// # Cancel safety
  ///
  /// This method is cancel safe. If `send` is used as the event in a
  /// [`tokio::select!`](crate::select) statement and some other branch
  /// completes first, then it is guaranteed that the message was not sent.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::io;
  /// use tokio::net::UdpSocket;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     // Bind socket
  ///     let socket = UdpSocket::bind("127.0.0.1:8080").await?;
  ///     socket.connect("127.0.0.1:8081").await?;
  ///
  ///     // Send a message
  ///     socket.send(b"hello world").await?;
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<BigInt> send({required List<int> buf});

  /// Sets the value of the `SO_BROADCAST` option for this socket.
  ///
  /// When enabled, this socket is allowed to send packets to a broadcast
  /// address.
  Future<void> setBroadcast({required bool on_});

  /// Sets the value of the `IP_MULTICAST_LOOP` option for this socket.
  ///
  /// If enabled, multicast packets will be looped back to the local socket.
  ///
  /// # Note
  ///
  /// This may not have any affect on IPv6 sockets.
  Future<void> setMulticastLoopV4({required bool on_});

  /// Sets the value of the `IPV6_MULTICAST_LOOP` option for this socket.
  ///
  /// Controls whether this socket sees the multicast packets it sends itself.
  ///
  /// # Note
  ///
  /// This may not have any affect on IPv4 sockets.
  Future<void> setMulticastLoopV6({required bool on_});

  /// Sets the value of the `IP_MULTICAST_TTL` option for this socket.
  ///
  /// Indicates the time-to-live value of outgoing multicast packets for
  /// this socket. The default value is 1 which means that multicast packets
  /// don't leave the local network unless explicitly requested.
  ///
  /// # Note
  ///
  /// This may not have any affect on IPv6 sockets.
  Future<void> setMulticastTtlV4({required int ttl});

  /// Sets the value for the `IP_TOS` option on this socket.
  ///
  /// This value sets the type-of-service field that is used in every packet
  /// sent from this socket.
  ///
  /// **NOTE:** On Windows, `IP_TOS` is only supported on [Windows 8+ or
  /// Windows Server 2012+.](https://docs.microsoft.com/en-us/windows/win32/winsock/ipproto-ip-socket-options)
  Future<void> setTos({required int tos});

  /// Sets the value for the `IP_TTL` option on this socket.
  ///
  /// This value sets the time-to-live field that is used in every packet sent
  /// from this socket.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::UdpSocket;
  /// # use std::io;
  ///
  /// # async fn dox() -> io::Result<()> {
  /// let sock = UdpSocket::bind("127.0.0.1:8080").await?;
  /// sock.set_ttl(60)?;
  ///
  /// # Ok(())
  /// # }
  /// ```
  Future<void> setTtl({required int ttl});

  /// Returns the value of the `SO_ERROR` option.
  ///
  /// # Examples
  /// ```
  /// use tokio::net::UdpSocket;
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     // Create a socket
  ///     let socket = UdpSocket::bind("0.0.0.0:8080").await?;
  ///
  ///     if let Ok(Some(err)) = socket.take_error() {
  ///         println!("Got error: {:?}", err);
  ///     }
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<Error?> takeError();

  /// Gets the value of the `IP_TOS` option for this socket.
  ///
  /// For more information about this option, see [`set_tos`].
  ///
  /// **NOTE:** On Windows, `IP_TOS` is only supported on [Windows 8+ or
  /// Windows Server 2012+.](https://docs.microsoft.com/en-us/windows/win32/winsock/ipproto-ip-socket-options)
  ///
  /// [`set_tos`]: Self::set_tos
  Future<int> tos();

  /// Tries to receive data on the socket without removing it from the input queue.
  /// On success, returns the number of bytes read and the sending address of the
  /// datagram.
  ///
  /// When there is no pending data, `Err(io::ErrorKind::WouldBlock)` is
  /// returned. This function is usually paired with `readable()`.
  ///
  /// # Notes
  ///
  /// On Windows, if the data is larger than the buffer specified, the buffer
  /// is filled with the first part of the data, and peek returns the error
  /// `WSAEMSGSIZE(10040)`. The excess data is lost.
  /// Make sure to always use a sufficiently large buffer to hold the
  /// maximum UDP packet size, which can be up to 65536 bytes in size.
  ///
  /// MacOS will return an error if you pass a zero-sized buffer.
  ///
  /// If you're merely interested in learning the sender of the data at the head of the queue,
  /// try [`try_peek_sender`].
  ///
  /// Note that the socket address **cannot** be implicitly trusted, because it is relatively
  /// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].
  /// Because UDP is stateless and does not validate the origin of a packet,
  /// the attacker does not need to be able to intercept traffic in order to interfere.
  /// It is important to be aware of this when designing your application-level protocol.
  ///
  /// [`try_peek_sender`]: method@Self::try_peek_sender
  /// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection
  Future<(BigInt, SocketAddr)> tryPeekFrom({required U8 buf});

  /// Try to retrieve the sender of the data at the head of the input queue.
  ///
  /// When there is no pending data, `Err(io::ErrorKind::WouldBlock)` is
  /// returned. This function is usually paired with `readable()`.
  ///
  /// Note that the socket address **cannot** be implicitly trusted, because it is relatively
  /// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].
  /// Because UDP is stateless and does not validate the origin of a packet,
  /// the attacker does not need to be able to intercept traffic in order to interfere.
  /// It is important to be aware of this when designing your application-level protocol.
  ///
  /// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection
  Future<SocketAddr> tryPeekSender();

  /// Tries to receive a single datagram message on the socket from the remote
  /// address to which it is connected. On success, returns the number of
  /// bytes read.
  ///
  /// This method must be called with valid byte array `buf` of sufficient size
  /// to hold the message bytes. If a message is too long to fit in the
  /// supplied buffer, excess bytes may be discarded.
  ///
  /// When there is no pending data, `Err(io::ErrorKind::WouldBlock)` is
  /// returned. This function is usually paired with `readable()`.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::UdpSocket;
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     // Connect to a peer
  ///     let socket = UdpSocket::bind("127.0.0.1:8080").await?;
  ///     socket.connect("127.0.0.1:8081").await?;
  ///
  ///     loop {
  ///         // Wait for the socket to be readable
  ///         socket.readable().await?;
  ///
  ///         // The buffer is **not** included in the async task and will
  ///         // only exist on the stack.
  ///         let mut buf = [0; 1024];
  ///
  ///         // Try to recv data, this may still fail with `WouldBlock`
  ///         // if the readiness event is a false positive.
  ///         match socket.try_recv(&mut buf) {
  ///             Ok(n) => {
  ///                 println!("GOT {:?}", &buf[..n]);
  ///                 break;
  ///             }
  ///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                 continue;
  ///             }
  ///             Err(e) => {
  ///                 return Err(e);
  ///             }
  ///         }
  ///     }
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<BigInt> tryRecv({required U8 buf});

  /// Tries to receive a single datagram message on the socket. On success,
  /// returns the number of bytes read and the origin.
  ///
  /// This method must be called with valid byte array `buf` of sufficient size
  /// to hold the message bytes. If a message is too long to fit in the
  /// supplied buffer, excess bytes may be discarded.
  ///
  /// When there is no pending data, `Err(io::ErrorKind::WouldBlock)` is
  /// returned. This function is usually paired with `readable()`.
  ///
  /// # Notes
  ///
  /// Note that the socket address **cannot** be implicitly trusted, because it is relatively
  /// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].
  /// Because UDP is stateless and does not validate the origin of a packet,
  /// the attacker does not need to be able to intercept traffic in order to interfere.
  /// It is important to be aware of this when designing your application-level protocol.
  ///
  /// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::UdpSocket;
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     // Connect to a peer
  ///     let socket = UdpSocket::bind("127.0.0.1:8080").await?;
  ///
  ///     loop {
  ///         // Wait for the socket to be readable
  ///         socket.readable().await?;
  ///
  ///         // The buffer is **not** included in the async task and will
  ///         // only exist on the stack.
  ///         let mut buf = [0; 1024];
  ///
  ///         // Try to recv data, this may still fail with `WouldBlock`
  ///         // if the readiness event is a false positive.
  ///         match socket.try_recv_from(&mut buf) {
  ///             Ok((n, _addr)) => {
  ///                 println!("GOT {:?}", &buf[..n]);
  ///                 break;
  ///             }
  ///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                 continue;
  ///             }
  ///             Err(e) => {
  ///                 return Err(e);
  ///             }
  ///         }
  ///     }
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<(BigInt, SocketAddr)> tryRecvFrom({required U8 buf});

  /// Tries to send data on the socket to the remote address to which it is
  /// connected.
  ///
  /// When the socket buffer is full, `Err(io::ErrorKind::WouldBlock)` is
  /// returned. This function is usually paired with `writable()`.
  ///
  /// # Returns
  ///
  /// If successful, `Ok(n)` is returned, where `n` is the number of bytes
  /// sent. If the socket is not ready to send data,
  /// `Err(ErrorKind::WouldBlock)` is returned.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::UdpSocket;
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     // Bind a UDP socket
  ///     let socket = UdpSocket::bind("127.0.0.1:8080").await?;
  ///
  ///     // Connect to a peer
  ///     socket.connect("127.0.0.1:8081").await?;
  ///
  ///     loop {
  ///         // Wait for the socket to be writable
  ///         socket.writable().await?;
  ///
  ///         // Try to send data, this may still fail with `WouldBlock`
  ///         // if the readiness event is a false positive.
  ///         match socket.try_send(b"hello world") {
  ///             Ok(n) => {
  ///                 break;
  ///             }
  ///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                 continue;
  ///             }
  ///             Err(e) => {
  ///                 return Err(e);
  ///             }
  ///         }
  ///     }
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<BigInt> trySend({required List<int> buf});

  /// Tries to send data on the socket to the given address, but if the send is
  /// blocked this will return right away.
  ///
  /// This function is usually paired with `writable()`.
  ///
  /// # Returns
  ///
  /// If successful, returns the number of bytes sent
  ///
  /// Users should ensure that when the remote cannot receive, the
  /// [`ErrorKind::WouldBlock`] is properly handled. An error can also occur
  /// if the IP version of the socket does not match that of `target`.
  ///
  /// [`ErrorKind::WouldBlock`]: std::io::ErrorKind::WouldBlock
  ///
  /// # Example
  ///
  /// ```no_run
  /// use tokio::net::UdpSocket;
  /// use std::error::Error;
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> Result<(), Box<dyn Error>> {
  ///     let socket = UdpSocket::bind("127.0.0.1:8080").await?;
  ///
  ///     let dst = "127.0.0.1:8081".parse()?;
  ///
  ///     loop {
  ///         socket.writable().await?;
  ///
  ///         match socket.try_send_to(&b"hello world"[..], dst) {
  ///             Ok(sent) => {
  ///                 println!("sent {} bytes", sent);
  ///                 break;
  ///             }
  ///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                 // Writable false positive.
  ///                 continue;
  ///             }
  ///             Err(e) => return Err(e.into()),
  ///         }
  ///     }
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<BigInt> trySendTo(
      {required List<int> buf, required SocketAddr target});

  /// Gets the value of the `IP_TTL` option for this socket.
  ///
  /// For more information about this option, see [`set_ttl`].
  ///
  /// [`set_ttl`]: method@Self::set_ttl
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::UdpSocket;
  /// # use std::io;
  ///
  /// # async fn dox() -> io::Result<()> {
  /// let sock = UdpSocket::bind("127.0.0.1:8080").await?;
  ///
  /// println!("{:?}", sock.ttl()?);
  /// # Ok(())
  /// # }
  /// ```
  Future<int> ttl();

  /// Waits for the socket to become writable.
  ///
  /// This function is equivalent to `ready(Interest::WRITABLE)` and is
  /// usually paired with `try_send()` or `try_send_to()`.
  ///
  /// The function may complete without the socket being writable. This is a
  /// false-positive and attempting a `try_send()` will return with
  /// `io::ErrorKind::WouldBlock`.
  ///
  /// # Cancel safety
  ///
  /// This method is cancel safe. Once a readiness event occurs, the method
  /// will continue to return immediately until the readiness event is
  /// consumed by an attempt to write that fails with `WouldBlock` or
  /// `Poll::Pending`.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::UdpSocket;
  /// use std::io;
  ///
  /// #[tokio::main]
  /// async fn main() -> io::Result<()> {
  ///     // Bind socket
  ///     let socket = UdpSocket::bind("127.0.0.1:8080").await?;
  ///     socket.connect("127.0.0.1:8081").await?;
  ///
  ///     loop {
  ///         // Wait for the socket to be writable
  ///         socket.writable().await?;
  ///
  ///         // Try to send data, this may still fail with `WouldBlock`
  ///         // if the readiness event is a false positive.
  ///         match socket.try_send(b"hello world") {
  ///             Ok(n) => {
  ///                 break;
  ///             }
  ///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                 continue;
  ///             }
  ///             Err(e) => {
  ///                 return Err(e);
  ///             }
  ///         }
  ///     }
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<void> writable();
}
