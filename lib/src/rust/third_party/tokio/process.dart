// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.40.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'process/windows.dart';

// These functions are ignored because they have generic arguments: `arg`, `args`, `current_dir`, `env_remove`, `env`, `envs`, `new`, `raw_arg`, `stderr`, `stdin`, `stdout`
// These types are ignored because they are not used by any `pub` functions: `ChildDropGuard`, `FusedChild`, `SpawnedChild`
// These functions have error during generation (see debug logs or enable `stop_on_error: true` for more details): `output`, `status`, `wait_with_output`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Child>>
abstract class Child implements RustOpaqueInterface {
  ChildStderr? get stderr;

  ChildStdin? get stdin;

  ChildStdout? get stdout;

  void set stderr(ChildStderr? stderr);

  void set stdin(ChildStdin? stdin);

  void set stdout(ChildStdout? stdout);

  /// Returns the OS-assigned process identifier associated with this child
  /// while it is still running.
  ///
  /// Once the child has been polled to completion this will return `None`.
  /// This is done to avoid confusion on platforms like Unix where the OS
  /// identifier could be reused once the process has completed.
  Future<int?> id();

  /// Forces the child to exit.
  ///
  /// This is equivalent to sending a `SIGKILL` on unix platforms.
  ///
  /// If the child has to be killed remotely, it is possible to do it using
  /// a combination of the select! macro and a `oneshot` channel. In the following
  /// example, the child will run until completion unless a message is sent on
  /// the `oneshot` channel. If that happens, the child is killed immediately
  /// using the `.kill()` method.
  ///
  /// ```no_run
  /// use tokio::process::Command;
  /// use tokio::sync::oneshot::channel;
  ///
  /// #[tokio::main]
  /// async fn main() {
  ///     let (send, recv) = channel::<()>();
  ///     let mut child = Command::new("sleep").arg("1").spawn().unwrap();
  ///     tokio::spawn(async move { send.send(()) });
  ///     tokio::select! {
  ///         _ = child.wait() => {}
  ///         _ = recv => child.kill().await.expect("kill failed"),
  ///     }
  /// }
  /// ```
  Future<void> kill();

  /// Extracts the raw handle of the process associated with this child while
  /// it is still running. Returns `None` if the child has exited.
  Future<RawHandle?> rawHandle();

  /// Attempts to force the child to exit, but does not wait for the request
  /// to take effect.
  ///
  /// On Unix platforms, this is the equivalent to sending a `SIGKILL`. Note
  /// that on Unix platforms it is possible for a zombie process to remain
  /// after a kill is sent; to avoid this, the caller should ensure that either
  /// `child.wait().await` or `child.try_wait()` is invoked successfully.
  Future<void> startKill();

  /// Attempts to collect the exit status of the child if it has already
  /// exited.
  ///
  /// This function will not block the calling thread and will only
  /// check to see if the child process has exited or not. If the child has
  /// exited then on Unix the process ID is reaped. This function is
  /// guaranteed to repeatedly return a successful exit status so long as the
  /// child has already exited.
  ///
  /// If the child has exited, then `Ok(Some(status))` is returned. If the
  /// exit status is not available at this time then `Ok(None)` is returned.
  /// If an error occurs, then that error is returned.
  ///
  /// Note that unlike `wait`, this function will not attempt to drop stdin,
  /// nor will it wake the current task if the child exits.
  Future<ExitStatus?> tryWait();

  /// Waits for the child to exit completely, returning the status that it
  /// exited with. This function will continue to have the same return value
  /// after it has been called at least once.
  ///
  /// The stdin handle to the child process, if any, will be closed
  /// before waiting. This helps avoid deadlock: it ensures that the
  /// child does not block waiting for input from the parent, while
  /// the parent waits for the child to exit.
  ///
  /// If the caller wishes to explicitly control when the child's stdin
  /// handle is closed, they may `.take()` it before calling `.wait()`:
  ///
  /// # Cancel safety
  ///
  /// This function is cancel safe.
  ///
  /// ```
  /// # #[cfg(not(unix))]fn main(){}
  /// # #[cfg(unix)]
  /// use tokio::io::AsyncWriteExt;
  /// # #[cfg(unix)]
  /// use tokio::process::Command;
  /// # #[cfg(unix)]
  /// use std::process::Stdio;
  ///
  /// # #[cfg(unix)]
  /// #[tokio::main]
  /// async fn main() {
  ///     let mut child = Command::new("cat")
  ///         .stdin(Stdio::piped())
  ///         .spawn()
  ///         .unwrap();
  ///
  ///     let mut stdin = child.stdin.take().unwrap();
  ///     tokio::spawn(async move {
  ///         // do something with stdin here...
  ///         stdin.write_all(b"hello world\n").await.unwrap();
  ///
  ///         // then drop when finished
  ///         drop(stdin);
  ///     });
  ///
  ///     // wait for the process to complete
  ///     let _ = child.wait().await;
  /// }
  /// ```
  Future<ExitStatus> wait();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChildStderr>>
abstract class ChildStderr implements RustOpaqueInterface {
  /// Creates an asynchronous `ChildStderr` from a synchronous one.
  ///
  /// # Errors
  ///
  /// This method may fail if an error is encountered when setting the pipe to
  /// non-blocking mode, or when registering the pipe with the runtime's IO
  /// driver.
  static Future<ChildStderr> fromStd({required ChildStderr inner}) =>
      RustLib.instance.api.tokioProcessChildStderrFromStd(inner: inner);

  /// Convert into [`OwnedHandle`].
  Future<OwnedHandle> intoOwnedHandle();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChildStdin>>
abstract class ChildStdin implements RustOpaqueInterface {
  /// Creates an asynchronous `ChildStdin` from a synchronous one.
  ///
  /// # Errors
  ///
  /// This method may fail if an error is encountered when setting the pipe to
  /// non-blocking mode, or when registering the pipe with the runtime's IO
  /// driver.
  static Future<ChildStdin> fromStd({required ChildStdin inner}) =>
      RustLib.instance.api.tokioProcessChildStdinFromStd(inner: inner);

  /// Convert into [`OwnedHandle`].
  Future<OwnedHandle> intoOwnedHandle();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChildStdout>>
abstract class ChildStdout implements RustOpaqueInterface {
  /// Creates an asynchronous `ChildStdout` from a synchronous one.
  ///
  /// # Errors
  ///
  /// This method may fail if an error is encountered when setting the pipe to
  /// non-blocking mode, or when registering the pipe with the runtime's IO
  /// driver.
  static Future<ChildStdout> fromStd({required ChildStdout inner}) =>
      RustLib.instance.api.tokioProcessChildStdoutFromStd(inner: inner);

  /// Convert into [`OwnedHandle`].
  Future<OwnedHandle> intoOwnedHandle();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Command>>
abstract class Command implements RustOpaqueInterface {
  /// Cheaply convert to a `&std::process::Command` for places where the type from the standard
  /// library is expected.
  Future<void> asStd();

  /// Sets the [process creation flags][1] to be passed to `CreateProcess`.
  ///
  /// These will always be ORed with `CREATE_UNICODE_ENVIRONMENT`.
  ///
  /// [1]: https://msdn.microsoft.com/en-us/library/windows/desktop/ms684863(v=vs.85).aspx
  Future<void> creationFlags({required int flags});

  /// Clears the entire environment map for the child process.
  ///
  /// # Examples
  ///
  /// Basic usage:
  ///
  /// ```no_run
  /// # async fn test() { // allow using await
  /// use tokio::process::Command;
  ///
  /// let output = Command::new("ls")
  ///         .env_clear()
  ///         .output().await.unwrap();
  /// # }
  /// ```
  Future<void> envClear();

  /// Controls whether a `kill` operation should be invoked on a spawned child
  /// process when its corresponding `Child` handle is dropped.
  ///
  /// By default, this value is assumed to be `false`, meaning the next spawned
  /// process will not be killed on drop, similar to the behavior of the standard
  /// library.
  ///
  /// # Caveats
  ///
  /// On Unix platforms processes must be "reaped" by their parent process after
  /// they have exited in order to release all OS resources. A child process which
  /// has exited, but has not yet been reaped by its parent is considered a "zombie"
  /// process. Such processes continue to count against limits imposed by the system,
  /// and having too many zombie processes present can prevent additional processes
  /// from being spawned.
  ///
  /// Although issuing a `kill` signal to the child process is a synchronous
  /// operation, the resulting zombie process cannot be `.await`ed inside of the
  /// destructor to avoid blocking other tasks. The tokio runtime will, on a
  /// best-effort basis, attempt to reap and clean up such processes in the
  /// background, but no additional guarantees are made with regard to
  /// how quickly or how often this procedure will take place.
  ///
  /// If stronger guarantees are required, it is recommended to avoid dropping
  /// a [`Child`] handle where possible, and instead utilize `child.wait().await`
  /// or `child.kill().await` where possible.
  Future<void> killOnDrop({required bool killOnDrop});

  /// Executes the command as a child process, returning a handle to it.
  ///
  /// By default, stdin, stdout and stderr are inherited from the parent.
  ///
  /// This method will spawn the child process synchronously and return a
  /// handle to a future-aware child process. The `Child` returned implements
  /// `Future` itself to acquire the `ExitStatus` of the child, and otherwise
  /// the `Child` has methods to acquire handles to the stdin, stdout, and
  /// stderr streams.
  ///
  /// All I/O this child does will be associated with the current default
  /// event loop.
  ///
  /// # Examples
  ///
  /// Basic usage:
  ///
  /// ```no_run
  /// use tokio::process::Command;
  ///
  /// async fn run_ls() -> std::process::ExitStatus {
  ///     Command::new("ls")
  ///         .spawn()
  ///         .expect("ls command failed to start")
  ///         .wait()
  ///         .await
  ///         .expect("ls command failed to run")
  /// }
  /// ```
  ///
  /// # Caveats
  ///
  /// ## Dropping/Cancellation
  ///
  /// Similar to the behavior to the standard library, and unlike the futures
  /// paradigm of dropping-implies-cancellation, a spawned process will, by
  /// default, continue to execute even after the `Child` handle has been dropped.
  ///
  /// The [`Command::kill_on_drop`] method can be used to modify this behavior
  /// and kill the child process if the `Child` wrapper is dropped before it
  /// has exited.
  ///
  /// ## Unix Processes
  ///
  /// On Unix platforms processes must be "reaped" by their parent process after
  /// they have exited in order to release all OS resources. A child process which
  /// has exited, but has not yet been reaped by its parent is considered a "zombie"
  /// process. Such processes continue to count against limits imposed by the system,
  /// and having too many zombie processes present can prevent additional processes
  /// from being spawned.
  ///
  /// The tokio runtime will, on a best-effort basis, attempt to reap and clean up
  /// any process which it has spawned. No additional guarantees are made with regard to
  /// how quickly or how often this procedure will take place.
  ///
  /// It is recommended to avoid dropping a [`Child`] process handle before it has been
  /// fully `await`ed if stricter cleanup guarantees are required.
  ///
  /// [`Command`]: crate::process::Command
  /// [`Command::kill_on_drop`]: crate::process::Command::kill_on_drop
  /// [`Child`]: crate::process::Child
  ///
  /// # Errors
  ///
  /// On Unix platforms this method will fail with `std::io::ErrorKind::WouldBlock`
  /// if the system process limit is reached (which includes other applications
  /// running on the system).
  Future<Child> spawn();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RawHandle>>
abstract class RawHandle implements RustOpaqueInterface {}
