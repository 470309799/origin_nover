// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.40.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../frb_generated.dart';
import '../../../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they have generic arguments: `delete`, `dns_resolver`, `get`, `head`, `local_address`, `patch`, `pool_idle_timeout`, `post`, `put`, `request`, `tcp_keepalive`, `user_agent`
// These types are ignored because they are not used by any `pub` functions: `ClientRef`, `Config`, `HttpVersionPref`, `PendingInner`, `PendingRequest`, `Pending`, `ResponseFuture`
// These functions have error during generation (see debug logs or enable `stop_on_error: true` for more details): `add_root_certificate`, `connect_timeout`, `connection_verbose`, `danger_accept_invalid_certs`, `default_headers`, `execute`, `http09_responses`, `http1_allow_obsolete_multiline_headers_in_responses`, `http1_allow_spaces_after_header_name_in_responses`, `http1_ignore_invalid_headers_in_responses`, `http1_only`, `http1_title_case_headers`, `http2_adaptive_window`, `http2_initial_connection_window_size`, `http2_initial_stream_window_size`, `http2_keep_alive_interval`, `http2_keep_alive_timeout`, `http2_keep_alive_while_idle`, `http2_max_frame_size`, `http2_prior_knowledge`, `https_only`, `identity`, `max_tls_version`, `min_tls_version`, `no_proxy`, `pool_max_idle_per_host`, `proxy`, `read_timeout`, `redirect`, `referer`, `resolve_to_addrs`, `tcp_nodelay`, `timeout`, `tls_built_in_root_certs`, `tls_built_in_webpki_certs`, `tls_info`, `tls_sni`, `use_preconfigured_tls`, `use_rustls_tls`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Client>>
abstract class Client implements RustOpaqueInterface {
  /// Creates a `ClientBuilder` to configure a `Client`.
  ///
  /// This is the same as `ClientBuilder::new()`.
  static Future<ClientBuilder> builder() =>
      RustLib.instance.api.reqwestAsyncImplClientClientBuilder();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Constructs a new `Client`.
  ///
  /// # Panics
  ///
  /// This method panics if a TLS backend cannot be initialized, or the resolver
  /// cannot load the system configuration.
  ///
  /// Use `Client::builder()` if you wish to handle the failure as an `Error`
  /// instead of panicking.
  static Future<Client> newInstance() =>
      RustLib.instance.api.reqwestAsyncImplClientClientNew();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ClientBuilder>>
abstract class ClientBuilder implements RustOpaqueInterface {
  /// Returns a `Client` that uses this `ClientBuilder` configuration.
  ///
  /// # Errors
  ///
  /// This method fails if a TLS backend cannot be initialized, or the resolver
  /// cannot load the system configuration.
  Future<Client> build();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Constructs a new `ClientBuilder`.
  ///
  /// This is the same as `Client::builder()`.
  static Future<ClientBuilder> newInstance() =>
      RustLib.instance.api.reqwestAsyncImplClientClientBuilderNew();

  /// Disable auto response body brotli decompression.
  ///
  /// This method exists even if the optional `brotli` feature is not enabled.
  /// This can be used to ensure a `Client` doesn't use brotli decompression
  /// even if another dependency were to enable the optional `brotli` feature.
  Future<ClientBuilder> noBrotli();

  /// Disable auto response body deflate decompression.
  ///
  /// This method exists even if the optional `deflate` feature is not enabled.
  /// This can be used to ensure a `Client` doesn't use deflate decompression
  /// even if another dependency were to enable the optional `deflate` feature.
  Future<ClientBuilder> noDeflate();

  /// Disable auto response body gzip decompression.
  ///
  /// This method exists even if the optional `gzip` feature is not enabled.
  /// This can be used to ensure a `Client` doesn't use gzip decompression
  /// even if another dependency were to enable the optional `gzip` feature.
  Future<ClientBuilder> noGzip();

  /// Disables the hickory-dns async resolver.
  ///
  /// This method exists even if the optional `hickory-dns` feature is not enabled.
  /// This can be used to ensure a `Client` doesn't use the hickory-dns async resolver
  /// even if another dependency were to enable the optional `hickory-dns` feature.
  Future<ClientBuilder> noHickoryDns();

  /// Disables the hickory-dns async resolver.
  ///
  /// This method exists even if the optional `hickory-dns` feature is not enabled.
  /// This can be used to ensure a `Client` doesn't use the hickory-dns async resolver
  /// even if another dependency were to enable the optional `hickory-dns` feature.
  Future<ClientBuilder> noTrustDns();

  /// Disable auto response body zstd decompression.
  ///
  /// This method exists even if the optional `zstd` feature is not enabled.
  /// This can be used to ensure a `Client` doesn't use zstd decompression
  /// even if another dependency were to enable the optional `zstd` feature.
  Future<ClientBuilder> noZstd();

  /// Override DNS resolution for specific domains to a particular IP address.
  ///
  /// Warning
  ///
  /// Since the DNS protocol has no notion of ports, if you wish to send
  /// traffic to a particular port you must include this port in the URL
  /// itself, any port in the overridden addr will be ignored and traffic sent
  /// to the conventional port for the given scheme (e.g. 80 for http).
  Future<ClientBuilder> resolve(
      {required String domain, required SocketAddr addr});
}
