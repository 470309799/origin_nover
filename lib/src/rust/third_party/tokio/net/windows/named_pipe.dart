// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.40.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../../frb_generated.dart';
import '../../../../lib.dart';
import '../../io.dart';
import '../../process.dart';
import '../../signal/windows.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they have generic arguments: `async_io`, `async_io`, `try_io`, `try_io`, `try_read_buf`, `try_read_buf`
// These functions have error during generation (see debug logs or enable `stop_on_error: true` for more details): `create_with_security_attributes_raw`, `create`, `open_with_security_attributes_raw`, `open`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ClientOptions>>
abstract class ClientOptions implements RustOpaqueInterface {
  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new named pipe builder with the default settings.
  ///
  /// ```
  /// use tokio::net::windows::named_pipe::{ServerOptions, ClientOptions};
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\tokio-named-pipe-client-new";
  ///
  /// # #[tokio::main] async fn main() -> std::io::Result<()> {
  /// // Server must be created in order for the client creation to succeed.
  /// let server = ServerOptions::new().create(PIPE_NAME)?;
  /// let client = ClientOptions::new().open(PIPE_NAME)?;
  /// # Ok(()) }
  /// ```
  static Future<ClientOptions> newInstance() =>
      RustLib.instance.api.tokioNetWindowsNamedPipeClientOptionsNew();

  /// The pipe mode.
  ///
  /// The default pipe mode is [`PipeMode::Byte`]. See [`PipeMode`] for
  /// documentation of what each mode means.
  Future<void> pipeMode({required PipeMode pipeMode});

  /// If the client supports reading data. This is enabled by default.
  ///
  /// This corresponds to setting [`GENERIC_READ`] in the call to [`CreateFile`].
  ///
  /// [`GENERIC_READ`]: https://docs.microsoft.com/en-us/windows/win32/secauthz/generic-access-rights
  /// [`CreateFile`]: https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew
  Future<void> read({required bool allowed});

  /// Sets qos flags which are combined with other flags and attributes in the
  /// call to [`CreateFile`].
  ///
  /// By default `security_qos_flags` is set to [`SECURITY_IDENTIFICATION`],
  /// calling this function would override that value completely with the
  /// argument specified.
  ///
  /// When `security_qos_flags` is not set, a malicious program can gain the
  /// elevated privileges of a privileged Rust process when it allows opening
  /// user-specified paths, by tricking it into opening a named pipe. So
  /// arguably `security_qos_flags` should also be set when opening arbitrary
  /// paths. However the bits can then conflict with other flags, specifically
  /// `FILE_FLAG_OPEN_NO_RECALL`.
  ///
  /// For information about possible values, see [Impersonation Levels] on the
  /// Windows Dev Center site. The `SECURITY_SQOS_PRESENT` flag is set
  /// automatically when using this method.
  ///
  /// [`CreateFile`]: https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea
  /// [`SECURITY_IDENTIFICATION`]: https://docs.rs/windows-sys/latest/windows_sys/Win32/Storage/FileSystem/constant.SECURITY_IDENTIFICATION.html
  /// [Impersonation Levels]: https://docs.microsoft.com/en-us/windows/win32/api/winnt/ne-winnt-security_impersonation_level
  Future<void> securityQosFlags({required int flags});

  /// If the created pipe supports writing data. This is enabled by default.
  ///
  /// This corresponds to setting [`GENERIC_WRITE`] in the call to [`CreateFile`].
  ///
  /// [`GENERIC_WRITE`]: https://docs.microsoft.com/en-us/windows/win32/secauthz/generic-access-rights
  /// [`CreateFile`]: https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew
  Future<void> write({required bool allowed});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[ IoSliceMut < '_ >]>>
abstract class IoSliceMut implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner< IoSlice < 'static>>>
abstract class IoSlice implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NamedPipeClient>>
abstract class NamedPipeClient implements RustOpaqueInterface {
  /// Constructs a new named pipe client from the specified raw handle.
  ///
  /// This function will consume ownership of the handle given, passing
  /// responsibility for closing the handle to the returned object.
  ///
  /// This function is also unsafe as the primitives currently returned have
  /// the contract that they are the sole owner of the file descriptor they
  /// are wrapping. Usage of this function could accidentally allow violating
  /// this contract which can cause memory unsafety in code that relies on it
  /// being true.
  ///
  /// # Errors
  ///
  /// This errors if called outside of a [Tokio Runtime], or in a runtime that
  /// has not [enabled I/O], or if any OS-specific I/O errors occur.
  ///
  /// [Tokio Runtime]: crate::runtime::Runtime
  /// [enabled I/O]: crate::runtime::Builder::enable_io
  static Future<NamedPipeClient> fromRawHandle({required RawHandle handle}) =>
      RustLib.instance.api
          .tokioNetWindowsNamedPipeNamedPipeClientFromRawHandle(handle: handle);

  /// Retrieves information about the named pipe the client is associated
  /// with.
  ///
  /// ```no_run
  /// use tokio::net::windows::named_pipe::{ClientOptions, PipeEnd, PipeMode};
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\tokio-named-pipe-client-info";
  ///
  /// # #[tokio::main] async fn main() -> std::io::Result<()> {
  /// let client = ClientOptions::new()
  ///     .open(PIPE_NAME)?;
  ///
  /// let client_info = client.info()?;
  ///
  /// assert_eq!(client_info.end, PipeEnd::Client);
  /// assert_eq!(client_info.mode, PipeMode::Message);
  /// assert_eq!(client_info.max_instances, 5);
  /// # Ok(()) }
  /// ```
  Future<PipeInfo> info();

  /// Polls for read readiness.
  ///
  /// If the pipe is not currently ready for reading, this method will
  /// store a clone of the `Waker` from the provided `Context`. When the pipe
  /// becomes ready for reading, `Waker::wake` will be called on the waker.
  ///
  /// Note that on multiple calls to `poll_read_ready` or `poll_read`, only
  /// the `Waker` from the `Context` passed to the most recent call is
  /// scheduled to receive a wakeup. (However, `poll_write_ready` retains a
  /// second, independent waker.)
  ///
  /// This function is intended for cases where creating and pinning a future
  /// via [`readable`] is not feasible. Where possible, using [`readable`] is
  /// preferred, as this supports polling from multiple tasks at once.
  ///
  /// # Return value
  ///
  /// The function returns:
  ///
  /// * `Poll::Pending` if the pipe is not ready for reading.
  /// * `Poll::Ready(Ok(()))` if the pipe is ready for reading.
  /// * `Poll::Ready(Err(e))` if an error is encountered.
  ///
  /// # Errors
  ///
  /// This function may encounter any standard I/O error except `WouldBlock`.
  ///
  /// [`readable`]: method@Self::readable
  Future<PollResult> pollReadReady({required Context cx});

  /// Polls for write readiness.
  ///
  /// If the pipe is not currently ready for writing, this method will
  /// store a clone of the `Waker` from the provided `Context`. When the pipe
  /// becomes ready for writing, `Waker::wake` will be called on the waker.
  ///
  /// Note that on multiple calls to `poll_write_ready` or `poll_write`, only
  /// the `Waker` from the `Context` passed to the most recent call is
  /// scheduled to receive a wakeup. (However, `poll_read_ready` retains a
  /// second, independent waker.)
  ///
  /// This function is intended for cases where creating and pinning a future
  /// via [`writable`] is not feasible. Where possible, using [`writable`] is
  /// preferred, as this supports polling from multiple tasks at once.
  ///
  /// # Return value
  ///
  /// The function returns:
  ///
  /// * `Poll::Pending` if the pipe is not ready for writing.
  /// * `Poll::Ready(Ok(()))` if the pipe is ready for writing.
  /// * `Poll::Ready(Err(e))` if an error is encountered.
  ///
  /// # Errors
  ///
  /// This function may encounter any standard I/O error except `WouldBlock`.
  ///
  /// [`writable`]: method@Self::writable
  Future<PollResult> pollWriteReady({required Context cx});

  /// Waits for the pipe to become readable.
  ///
  /// This function is equivalent to `ready(Interest::READABLE)` and is usually
  /// paired with `try_read()`.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::windows::named_pipe;
  /// use std::error::Error;
  /// use std::io;
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\tokio-named-pipe-client-readable";
  ///
  /// #[tokio::main]
  /// async fn main() -> Result<(), Box<dyn Error>> {
  ///     let client = named_pipe::ClientOptions::new().open(PIPE_NAME)?;
  ///
  ///     let mut msg = vec![0; 1024];
  ///
  ///     loop {
  ///         // Wait for the pipe to be readable
  ///         client.readable().await?;
  ///
  ///         // Try to read data, this may still fail with `WouldBlock`
  ///         // if the readiness event is a false positive.
  ///         match client.try_read(&mut msg) {
  ///             Ok(n) => {
  ///                 msg.truncate(n);
  ///                 break;
  ///             }
  ///             Err(e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                 continue;
  ///             }
  ///             Err(e) => {
  ///                 return Err(e.into());
  ///             }
  ///         }
  ///     }
  ///
  ///     println!("GOT = {:?}", msg);
  ///     Ok(())
  /// }
  /// ```
  Future<void> readable();

  /// Waits for any of the requested ready states.
  ///
  /// This function is usually paired with `try_read()` or `try_write()`. It
  /// can be used to concurrently read / write to the same pipe on a single
  /// task without splitting the pipe.
  ///
  /// The function may complete without the pipe being ready. This is a
  /// false-positive and attempting an operation will return with
  /// `io::ErrorKind::WouldBlock`. The function can also return with an empty
  /// [`Ready`] set, so you should always check the returned value and possibly
  /// wait again if the requested states are not set.
  ///
  /// # Examples
  ///
  /// Concurrently read and write to the pipe on the same task without
  /// splitting.
  ///
  /// ```no_run
  /// use tokio::io::Interest;
  /// use tokio::net::windows::named_pipe;
  /// use std::error::Error;
  /// use std::io;
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\tokio-named-pipe-client-ready";
  ///
  /// #[tokio::main]
  /// async fn main() -> Result<(), Box<dyn Error>> {
  ///     let client = named_pipe::ClientOptions::new().open(PIPE_NAME)?;
  ///
  ///     loop {
  ///         let ready = client.ready(Interest::READABLE | Interest::WRITABLE).await?;
  ///
  ///         if ready.is_readable() {
  ///             let mut data = vec![0; 1024];
  ///             // Try to read data, this may still fail with `WouldBlock`
  ///             // if the readiness event is a false positive.
  ///             match client.try_read(&mut data) {
  ///                 Ok(n) => {
  ///                     println!("read {} bytes", n);
  ///                 }
  ///                 Err(e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                     continue;
  ///                 }
  ///                 Err(e) => {
  ///                     return Err(e.into());
  ///                 }
  ///             }
  ///         }
  ///
  ///         if ready.is_writable() {
  ///             // Try to write data, this may still fail with `WouldBlock`
  ///             // if the readiness event is a false positive.
  ///             match client.try_write(b"hello world") {
  ///                 Ok(n) => {
  ///                     println!("write {} bytes", n);
  ///                 }
  ///                 Err(e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                     continue;
  ///                 }
  ///                 Err(e) => {
  ///                     return Err(e.into());
  ///                 }
  ///             }
  ///         }
  ///     }
  /// }
  /// ```
  Future<Ready> ready({required Interest interest});

  /// Tries to read data from the pipe into the provided buffer, returning how
  /// many bytes were read.
  ///
  /// Receives any pending data from the pipe but does not wait for new data
  /// to arrive. On success, returns the number of bytes read. Because
  /// `try_read()` is non-blocking, the buffer does not have to be stored by
  /// the async task and can exist entirely on the stack.
  ///
  /// Usually, [`readable()`] or [`ready()`] is used with this function.
  ///
  /// [`readable()`]: NamedPipeClient::readable()
  /// [`ready()`]: NamedPipeClient::ready()
  ///
  /// # Return
  ///
  /// If data is successfully read, `Ok(n)` is returned, where `n` is the
  /// number of bytes read. If `n` is `0`, then it can indicate one of two scenarios:
  ///
  /// 1. The pipe's read half is closed and will no longer yield data.
  /// 2. The specified buffer was 0 bytes in length.
  ///
  /// If the pipe is not ready to read data,
  /// `Err(io::ErrorKind::WouldBlock)` is returned.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::windows::named_pipe;
  /// use std::error::Error;
  /// use std::io;
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\tokio-named-pipe-client-try-read";
  ///
  /// #[tokio::main]
  /// async fn main() -> Result<(), Box<dyn Error>> {
  ///     let client = named_pipe::ClientOptions::new().open(PIPE_NAME)?;
  ///
  ///     loop {
  ///         // Wait for the pipe to be readable
  ///         client.readable().await?;
  ///
  ///         // Creating the buffer **after** the `await` prevents it from
  ///         // being stored in the async task.
  ///         let mut buf = [0; 4096];
  ///
  ///         // Try to read data, this may still fail with `WouldBlock`
  ///         // if the readiness event is a false positive.
  ///         match client.try_read(&mut buf) {
  ///             Ok(0) => break,
  ///             Ok(n) => {
  ///                 println!("read {} bytes", n);
  ///             }
  ///             Err(e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                 continue;
  ///             }
  ///             Err(e) => {
  ///                 return Err(e.into());
  ///             }
  ///         }
  ///     }
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<BigInt> tryRead({required U8 buf});

  /// Tries to read data from the pipe into the provided buffers, returning
  /// how many bytes were read.
  ///
  /// Data is copied to fill each buffer in order, with the final buffer
  /// written to possibly being only partially filled. This method behaves
  /// equivalently to a single call to [`try_read()`] with concatenated
  /// buffers.
  ///
  /// Receives any pending data from the pipe but does not wait for new data
  /// to arrive. On success, returns the number of bytes read. Because
  /// `try_read_vectored()` is non-blocking, the buffer does not have to be
  /// stored by the async task and can exist entirely on the stack.
  ///
  /// Usually, [`readable()`] or [`ready()`] is used with this function.
  ///
  /// [`try_read()`]: NamedPipeClient::try_read()
  /// [`readable()`]: NamedPipeClient::readable()
  /// [`ready()`]: NamedPipeClient::ready()
  ///
  /// # Return
  ///
  /// If data is successfully read, `Ok(n)` is returned, where `n` is the
  /// number of bytes read. `Ok(0)` indicates the pipe's read half is closed
  /// and will no longer yield data. If the pipe is not ready to read data
  /// `Err(io::ErrorKind::WouldBlock)` is returned.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::windows::named_pipe;
  /// use std::error::Error;
  /// use std::io::{self, IoSliceMut};
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\tokio-named-pipe-client-try-read-vectored";
  ///
  /// #[tokio::main]
  /// async fn main() -> Result<(), Box<dyn Error>> {
  ///     let client = named_pipe::ClientOptions::new().open(PIPE_NAME)?;
  ///
  ///     loop {
  ///         // Wait for the pipe to be readable
  ///         client.readable().await?;
  ///
  ///         // Creating the buffer **after** the `await` prevents it from
  ///         // being stored in the async task.
  ///         let mut buf_a = [0; 512];
  ///         let mut buf_b = [0; 1024];
  ///         let mut bufs = [
  ///             IoSliceMut::new(&mut buf_a),
  ///             IoSliceMut::new(&mut buf_b),
  ///         ];
  ///
  ///         // Try to read data, this may still fail with `WouldBlock`
  ///         // if the readiness event is a false positive.
  ///         match client.try_read_vectored(&mut bufs) {
  ///             Ok(0) => break,
  ///             Ok(n) => {
  ///                 println!("read {} bytes", n);
  ///             }
  ///             Err(e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                 continue;
  ///             }
  ///             Err(e) => {
  ///                 return Err(e.into());
  ///             }
  ///         }
  ///     }
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<BigInt> tryReadVectored({required IoSliceMut bufs});

  /// Tries to write a buffer to the pipe, returning how many bytes were
  /// written.
  ///
  /// The function will attempt to write the entire contents of `buf`, but
  /// only part of the buffer may be written.
  ///
  /// This function is usually paired with `writable()`.
  ///
  /// # Return
  ///
  /// If data is successfully written, `Ok(n)` is returned, where `n` is the
  /// number of bytes written. If the pipe is not ready to write data,
  /// `Err(io::ErrorKind::WouldBlock)` is returned.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::windows::named_pipe;
  /// use std::error::Error;
  /// use std::io;
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\tokio-named-pipe-client-try-write";
  ///
  /// #[tokio::main]
  /// async fn main() -> Result<(), Box<dyn Error>> {
  ///     let client = named_pipe::ClientOptions::new().open(PIPE_NAME)?;
  ///
  ///     loop {
  ///         // Wait for the pipe to be writable
  ///         client.writable().await?;
  ///
  ///         // Try to write data, this may still fail with `WouldBlock`
  ///         // if the readiness event is a false positive.
  ///         match client.try_write(b"hello world") {
  ///             Ok(n) => {
  ///                 break;
  ///             }
  ///             Err(e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                 continue;
  ///             }
  ///             Err(e) => {
  ///                 return Err(e.into());
  ///             }
  ///         }
  ///     }
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<BigInt> tryWrite({required List<int> buf});

  /// Tries to write several buffers to the pipe, returning how many bytes
  /// were written.
  ///
  /// Data is written from each buffer in order, with the final buffer read
  /// from possible being only partially consumed. This method behaves
  /// equivalently to a single call to [`try_write()`] with concatenated
  /// buffers.
  ///
  /// This function is usually paired with `writable()`.
  ///
  /// [`try_write()`]: NamedPipeClient::try_write()
  ///
  /// # Return
  ///
  /// If data is successfully written, `Ok(n)` is returned, where `n` is the
  /// number of bytes written. If the pipe is not ready to write data,
  /// `Err(io::ErrorKind::WouldBlock)` is returned.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::windows::named_pipe;
  /// use std::error::Error;
  /// use std::io;
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\tokio-named-pipe-client-try-write-vectored";
  ///
  /// #[tokio::main]
  /// async fn main() -> Result<(), Box<dyn Error>> {
  ///     let client = named_pipe::ClientOptions::new().open(PIPE_NAME)?;
  ///
  ///     let bufs = [io::IoSlice::new(b"hello "), io::IoSlice::new(b"world")];
  ///
  ///     loop {
  ///         // Wait for the pipe to be writable
  ///         client.writable().await?;
  ///
  ///         // Try to write data, this may still fail with `WouldBlock`
  ///         // if the readiness event is a false positive.
  ///         match client.try_write_vectored(&bufs) {
  ///             Ok(n) => {
  ///                 break;
  ///             }
  ///             Err(e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                 continue;
  ///             }
  ///             Err(e) => {
  ///                 return Err(e.into());
  ///             }
  ///         }
  ///     }
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<BigInt> tryWriteVectored({required List<IoSlice> buf});

  /// Waits for the pipe to become writable.
  ///
  /// This function is equivalent to `ready(Interest::WRITABLE)` and is usually
  /// paired with `try_write()`.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::windows::named_pipe;
  /// use std::error::Error;
  /// use std::io;
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\tokio-named-pipe-client-writable";
  ///
  /// #[tokio::main]
  /// async fn main() -> Result<(), Box<dyn Error>> {
  ///     let client = named_pipe::ClientOptions::new().open(PIPE_NAME)?;
  ///
  ///     loop {
  ///         // Wait for the pipe to be writable
  ///         client.writable().await?;
  ///
  ///         // Try to write data, this may still fail with `WouldBlock`
  ///         // if the readiness event is a false positive.
  ///         match client.try_write(b"hello world") {
  ///             Ok(n) => {
  ///                 break;
  ///             }
  ///             Err(e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                 continue;
  ///             }
  ///             Err(e) => {
  ///                 return Err(e.into());
  ///             }
  ///         }
  ///     }
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<void> writable();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NamedPipeServer>>
abstract class NamedPipeServer implements RustOpaqueInterface {
  /// Enables a named pipe server process to wait for a client process to
  /// connect to an instance of a named pipe. A client process connects by
  /// creating a named pipe with the same name.
  ///
  /// This corresponds to the [`ConnectNamedPipe`] system call.
  ///
  /// # Cancel safety
  ///
  /// This method is cancellation safe in the sense that if it is used as the
  /// event in a [`select!`](crate::select) statement and some other branch
  /// completes first, then no connection events have been lost.
  ///
  /// [`ConnectNamedPipe`]: https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe
  ///
  /// # Example
  ///
  /// ```no_run
  /// use tokio::net::windows::named_pipe::ServerOptions;
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\mynamedpipe";
  ///
  /// # #[tokio::main] async fn main() -> std::io::Result<()> {
  /// let pipe = ServerOptions::new().create(PIPE_NAME)?;
  ///
  /// // Wait for a client to connect.
  /// pipe.connect().await?;
  ///
  /// // Use the connected client...
  /// # Ok(()) }
  /// ```
  Future<void> connect();

  /// Disconnects the server end of a named pipe instance from a client
  /// process.
  ///
  /// ```
  /// use tokio::io::AsyncWriteExt;
  /// use tokio::net::windows::named_pipe::{ClientOptions, ServerOptions};
  /// use windows_sys::Win32::Foundation::ERROR_PIPE_NOT_CONNECTED;
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\tokio-named-pipe-disconnect";
  ///
  /// # #[tokio::main] async fn main() -> std::io::Result<()> {
  /// let server = ServerOptions::new()
  ///     .create(PIPE_NAME)?;
  ///
  /// let mut client = ClientOptions::new()
  ///     .open(PIPE_NAME)?;
  ///
  /// // Wait for a client to become connected.
  /// server.connect().await?;
  ///
  /// // Forcibly disconnect the client.
  /// server.disconnect()?;
  ///
  /// // Write fails with an OS-specific error after client has been
  /// // disconnected.
  /// let e = client.write(b"ping").await.unwrap_err();
  /// assert_eq!(e.raw_os_error(), Some(ERROR_PIPE_NOT_CONNECTED as i32));
  /// # Ok(()) }
  /// ```
  Future<void> disconnect();

  /// Constructs a new named pipe server from the specified raw handle.
  ///
  /// This function will consume ownership of the handle given, passing
  /// responsibility for closing the handle to the returned object.
  ///
  /// This function is also unsafe as the primitives currently returned have
  /// the contract that they are the sole owner of the file descriptor they
  /// are wrapping. Usage of this function could accidentally allow violating
  /// this contract which can cause memory unsafety in code that relies on it
  /// being true.
  ///
  /// # Errors
  ///
  /// This errors if called outside of a [Tokio Runtime], or in a runtime that
  /// has not [enabled I/O], or if any OS-specific I/O errors occur.
  ///
  /// [Tokio Runtime]: crate::runtime::Runtime
  /// [enabled I/O]: crate::runtime::Builder::enable_io
  static Future<NamedPipeServer> fromRawHandle({required RawHandle handle}) =>
      RustLib.instance.api
          .tokioNetWindowsNamedPipeNamedPipeServerFromRawHandle(handle: handle);

  /// Retrieves information about the named pipe the server is associated
  /// with.
  ///
  /// ```no_run
  /// use tokio::net::windows::named_pipe::{PipeEnd, PipeMode, ServerOptions};
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\tokio-named-pipe-server-info";
  ///
  /// # #[tokio::main] async fn main() -> std::io::Result<()> {
  /// let server = ServerOptions::new()
  ///     .pipe_mode(PipeMode::Message)
  ///     .max_instances(5)
  ///     .create(PIPE_NAME)?;
  ///
  /// let server_info = server.info()?;
  ///
  /// assert_eq!(server_info.end, PipeEnd::Server);
  /// assert_eq!(server_info.mode, PipeMode::Message);
  /// assert_eq!(server_info.max_instances, 5);
  /// # Ok(()) }
  /// ```
  Future<PipeInfo> info();

  /// Polls for read readiness.
  ///
  /// If the pipe is not currently ready for reading, this method will
  /// store a clone of the `Waker` from the provided `Context`. When the pipe
  /// becomes ready for reading, `Waker::wake` will be called on the waker.
  ///
  /// Note that on multiple calls to `poll_read_ready` or `poll_read`, only
  /// the `Waker` from the `Context` passed to the most recent call is
  /// scheduled to receive a wakeup. (However, `poll_write_ready` retains a
  /// second, independent waker.)
  ///
  /// This function is intended for cases where creating and pinning a future
  /// via [`readable`] is not feasible. Where possible, using [`readable`] is
  /// preferred, as this supports polling from multiple tasks at once.
  ///
  /// # Return value
  ///
  /// The function returns:
  ///
  /// * `Poll::Pending` if the pipe is not ready for reading.
  /// * `Poll::Ready(Ok(()))` if the pipe is ready for reading.
  /// * `Poll::Ready(Err(e))` if an error is encountered.
  ///
  /// # Errors
  ///
  /// This function may encounter any standard I/O error except `WouldBlock`.
  ///
  /// [`readable`]: method@Self::readable
  Future<PollResult> pollReadReady({required Context cx});

  /// Polls for write readiness.
  ///
  /// If the pipe is not currently ready for writing, this method will
  /// store a clone of the `Waker` from the provided `Context`. When the pipe
  /// becomes ready for writing, `Waker::wake` will be called on the waker.
  ///
  /// Note that on multiple calls to `poll_write_ready` or `poll_write`, only
  /// the `Waker` from the `Context` passed to the most recent call is
  /// scheduled to receive a wakeup. (However, `poll_read_ready` retains a
  /// second, independent waker.)
  ///
  /// This function is intended for cases where creating and pinning a future
  /// via [`writable`] is not feasible. Where possible, using [`writable`] is
  /// preferred, as this supports polling from multiple tasks at once.
  ///
  /// # Return value
  ///
  /// The function returns:
  ///
  /// * `Poll::Pending` if the pipe is not ready for writing.
  /// * `Poll::Ready(Ok(()))` if the pipe is ready for writing.
  /// * `Poll::Ready(Err(e))` if an error is encountered.
  ///
  /// # Errors
  ///
  /// This function may encounter any standard I/O error except `WouldBlock`.
  ///
  /// [`writable`]: method@Self::writable
  Future<PollResult> pollWriteReady({required Context cx});

  /// Waits for the pipe to become readable.
  ///
  /// This function is equivalent to `ready(Interest::READABLE)` and is usually
  /// paired with `try_read()`.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::windows::named_pipe;
  /// use std::error::Error;
  /// use std::io;
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\tokio-named-pipe-server-readable";
  ///
  /// #[tokio::main]
  /// async fn main() -> Result<(), Box<dyn Error>> {
  ///     let server = named_pipe::ServerOptions::new()
  ///         .create(PIPE_NAME)?;
  ///
  ///     let mut msg = vec![0; 1024];
  ///
  ///     loop {
  ///         // Wait for the pipe to be readable
  ///         server.readable().await?;
  ///
  ///         // Try to read data, this may still fail with `WouldBlock`
  ///         // if the readiness event is a false positive.
  ///         match server.try_read(&mut msg) {
  ///             Ok(n) => {
  ///                 msg.truncate(n);
  ///                 break;
  ///             }
  ///             Err(e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                 continue;
  ///             }
  ///             Err(e) => {
  ///                 return Err(e.into());
  ///             }
  ///         }
  ///     }
  ///
  ///     println!("GOT = {:?}", msg);
  ///     Ok(())
  /// }
  /// ```
  Future<void> readable();

  /// Waits for any of the requested ready states.
  ///
  /// This function is usually paired with `try_read()` or `try_write()`. It
  /// can be used to concurrently read / write to the same pipe on a single
  /// task without splitting the pipe.
  ///
  /// The function may complete without the pipe being ready. This is a
  /// false-positive and attempting an operation will return with
  /// `io::ErrorKind::WouldBlock`. The function can also return with an empty
  /// [`Ready`] set, so you should always check the returned value and possibly
  /// wait again if the requested states are not set.
  ///
  /// # Examples
  ///
  /// Concurrently read and write to the pipe on the same task without
  /// splitting.
  ///
  /// ```no_run
  /// use tokio::io::Interest;
  /// use tokio::net::windows::named_pipe;
  /// use std::error::Error;
  /// use std::io;
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\tokio-named-pipe-server-ready";
  ///
  /// #[tokio::main]
  /// async fn main() -> Result<(), Box<dyn Error>> {
  ///     let server = named_pipe::ServerOptions::new()
  ///         .create(PIPE_NAME)?;
  ///
  ///     loop {
  ///         let ready = server.ready(Interest::READABLE | Interest::WRITABLE).await?;
  ///
  ///         if ready.is_readable() {
  ///             let mut data = vec![0; 1024];
  ///             // Try to read data, this may still fail with `WouldBlock`
  ///             // if the readiness event is a false positive.
  ///             match server.try_read(&mut data) {
  ///                 Ok(n) => {
  ///                     println!("read {} bytes", n);
  ///                 }
  ///                 Err(e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                     continue;
  ///                 }
  ///                 Err(e) => {
  ///                     return Err(e.into());
  ///                 }
  ///             }
  ///         }
  ///
  ///         if ready.is_writable() {
  ///             // Try to write data, this may still fail with `WouldBlock`
  ///             // if the readiness event is a false positive.
  ///             match server.try_write(b"hello world") {
  ///                 Ok(n) => {
  ///                     println!("write {} bytes", n);
  ///                 }
  ///                 Err(e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                     continue;
  ///                 }
  ///                 Err(e) => {
  ///                     return Err(e.into());
  ///                 }
  ///             }
  ///         }
  ///     }
  /// }
  /// ```
  Future<Ready> ready({required Interest interest});

  /// Tries to read data from the pipe into the provided buffer, returning how
  /// many bytes were read.
  ///
  /// Receives any pending data from the pipe but does not wait for new data
  /// to arrive. On success, returns the number of bytes read. Because
  /// `try_read()` is non-blocking, the buffer does not have to be stored by
  /// the async task and can exist entirely on the stack.
  ///
  /// Usually, [`readable()`] or [`ready()`] is used with this function.
  ///
  /// [`readable()`]: NamedPipeServer::readable()
  /// [`ready()`]: NamedPipeServer::ready()
  ///
  /// # Return
  ///
  /// If data is successfully read, `Ok(n)` is returned, where `n` is the
  /// number of bytes read. If `n` is `0`, then it can indicate one of two scenarios:
  ///
  /// 1. The pipe's read half is closed and will no longer yield data.
  /// 2. The specified buffer was 0 bytes in length.
  ///
  /// If the pipe is not ready to read data,
  /// `Err(io::ErrorKind::WouldBlock)` is returned.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::windows::named_pipe;
  /// use std::error::Error;
  /// use std::io;
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\tokio-named-pipe-server-try-read";
  ///
  /// #[tokio::main]
  /// async fn main() -> Result<(), Box<dyn Error>> {
  ///     let server = named_pipe::ServerOptions::new()
  ///         .create(PIPE_NAME)?;
  ///
  ///     loop {
  ///         // Wait for the pipe to be readable
  ///         server.readable().await?;
  ///
  ///         // Creating the buffer **after** the `await` prevents it from
  ///         // being stored in the async task.
  ///         let mut buf = [0; 4096];
  ///
  ///         // Try to read data, this may still fail with `WouldBlock`
  ///         // if the readiness event is a false positive.
  ///         match server.try_read(&mut buf) {
  ///             Ok(0) => break,
  ///             Ok(n) => {
  ///                 println!("read {} bytes", n);
  ///             }
  ///             Err(e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                 continue;
  ///             }
  ///             Err(e) => {
  ///                 return Err(e.into());
  ///             }
  ///         }
  ///     }
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<BigInt> tryRead({required U8 buf});

  /// Tries to read data from the pipe into the provided buffers, returning
  /// how many bytes were read.
  ///
  /// Data is copied to fill each buffer in order, with the final buffer
  /// written to possibly being only partially filled. This method behaves
  /// equivalently to a single call to [`try_read()`] with concatenated
  /// buffers.
  ///
  /// Receives any pending data from the pipe but does not wait for new data
  /// to arrive. On success, returns the number of bytes read. Because
  /// `try_read_vectored()` is non-blocking, the buffer does not have to be
  /// stored by the async task and can exist entirely on the stack.
  ///
  /// Usually, [`readable()`] or [`ready()`] is used with this function.
  ///
  /// [`try_read()`]: NamedPipeServer::try_read()
  /// [`readable()`]: NamedPipeServer::readable()
  /// [`ready()`]: NamedPipeServer::ready()
  ///
  /// # Return
  ///
  /// If data is successfully read, `Ok(n)` is returned, where `n` is the
  /// number of bytes read. `Ok(0)` indicates the pipe's read half is closed
  /// and will no longer yield data. If the pipe is not ready to read data
  /// `Err(io::ErrorKind::WouldBlock)` is returned.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::windows::named_pipe;
  /// use std::error::Error;
  /// use std::io::{self, IoSliceMut};
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\tokio-named-pipe-server-try-read-vectored";
  ///
  /// #[tokio::main]
  /// async fn main() -> Result<(), Box<dyn Error>> {
  ///     let server = named_pipe::ServerOptions::new()
  ///         .create(PIPE_NAME)?;
  ///
  ///     loop {
  ///         // Wait for the pipe to be readable
  ///         server.readable().await?;
  ///
  ///         // Creating the buffer **after** the `await` prevents it from
  ///         // being stored in the async task.
  ///         let mut buf_a = [0; 512];
  ///         let mut buf_b = [0; 1024];
  ///         let mut bufs = [
  ///             IoSliceMut::new(&mut buf_a),
  ///             IoSliceMut::new(&mut buf_b),
  ///         ];
  ///
  ///         // Try to read data, this may still fail with `WouldBlock`
  ///         // if the readiness event is a false positive.
  ///         match server.try_read_vectored(&mut bufs) {
  ///             Ok(0) => break,
  ///             Ok(n) => {
  ///                 println!("read {} bytes", n);
  ///             }
  ///             Err(e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                 continue;
  ///             }
  ///             Err(e) => {
  ///                 return Err(e.into());
  ///             }
  ///         }
  ///     }
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<BigInt> tryReadVectored({required IoSliceMut bufs});

  /// Tries to write a buffer to the pipe, returning how many bytes were
  /// written.
  ///
  /// The function will attempt to write the entire contents of `buf`, but
  /// only part of the buffer may be written.
  ///
  /// This function is usually paired with `writable()`.
  ///
  /// # Return
  ///
  /// If data is successfully written, `Ok(n)` is returned, where `n` is the
  /// number of bytes written. If the pipe is not ready to write data,
  /// `Err(io::ErrorKind::WouldBlock)` is returned.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::windows::named_pipe;
  /// use std::error::Error;
  /// use std::io;
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\tokio-named-pipe-server-try-write";
  ///
  /// #[tokio::main]
  /// async fn main() -> Result<(), Box<dyn Error>> {
  ///     let server = named_pipe::ServerOptions::new()
  ///         .create(PIPE_NAME)?;
  ///
  ///     loop {
  ///         // Wait for the pipe to be writable
  ///         server.writable().await?;
  ///
  ///         // Try to write data, this may still fail with `WouldBlock`
  ///         // if the readiness event is a false positive.
  ///         match server.try_write(b"hello world") {
  ///             Ok(n) => {
  ///                 break;
  ///             }
  ///             Err(e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                 continue;
  ///             }
  ///             Err(e) => {
  ///                 return Err(e.into());
  ///             }
  ///         }
  ///     }
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<BigInt> tryWrite({required List<int> buf});

  /// Tries to write several buffers to the pipe, returning how many bytes
  /// were written.
  ///
  /// Data is written from each buffer in order, with the final buffer read
  /// from possible being only partially consumed. This method behaves
  /// equivalently to a single call to [`try_write()`] with concatenated
  /// buffers.
  ///
  /// This function is usually paired with `writable()`.
  ///
  /// [`try_write()`]: NamedPipeServer::try_write()
  ///
  /// # Return
  ///
  /// If data is successfully written, `Ok(n)` is returned, where `n` is the
  /// number of bytes written. If the pipe is not ready to write data,
  /// `Err(io::ErrorKind::WouldBlock)` is returned.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::windows::named_pipe;
  /// use std::error::Error;
  /// use std::io;
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\tokio-named-pipe-server-try-write-vectored";
  ///
  /// #[tokio::main]
  /// async fn main() -> Result<(), Box<dyn Error>> {
  ///     let server = named_pipe::ServerOptions::new()
  ///         .create(PIPE_NAME)?;
  ///
  ///     let bufs = [io::IoSlice::new(b"hello "), io::IoSlice::new(b"world")];
  ///
  ///     loop {
  ///         // Wait for the pipe to be writable
  ///         server.writable().await?;
  ///
  ///         // Try to write data, this may still fail with `WouldBlock`
  ///         // if the readiness event is a false positive.
  ///         match server.try_write_vectored(&bufs) {
  ///             Ok(n) => {
  ///                 break;
  ///             }
  ///             Err(e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                 continue;
  ///             }
  ///             Err(e) => {
  ///                 return Err(e.into());
  ///             }
  ///         }
  ///     }
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<BigInt> tryWriteVectored({required List<IoSlice> buf});

  /// Waits for the pipe to become writable.
  ///
  /// This function is equivalent to `ready(Interest::WRITABLE)` and is usually
  /// paired with `try_write()`.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::net::windows::named_pipe;
  /// use std::error::Error;
  /// use std::io;
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\tokio-named-pipe-server-writable";
  ///
  /// #[tokio::main]
  /// async fn main() -> Result<(), Box<dyn Error>> {
  ///     let server = named_pipe::ServerOptions::new()
  ///         .create(PIPE_NAME)?;
  ///
  ///     loop {
  ///         // Wait for the pipe to be writable
  ///         server.writable().await?;
  ///
  ///         // Try to write data, this may still fail with `WouldBlock`
  ///         // if the readiness event is a false positive.
  ///         match server.try_write(b"hello world") {
  ///             Ok(n) => {
  ///                 break;
  ///             }
  ///             Err(e) if e.kind() == io::ErrorKind::WouldBlock => {
  ///                 continue;
  ///             }
  ///             Err(e) => {
  ///                 return Err(e.into());
  ///             }
  ///         }
  ///     }
  ///
  ///     Ok(())
  /// }
  /// ```
  Future<void> writable();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Poll < Result < () > >>>
abstract class PollResult implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ServerOptions>>
abstract class ServerOptions implements RustOpaqueInterface {
  /// The flow of data in the pipe goes from client to server only.
  ///
  /// This corresponds to setting [`PIPE_ACCESS_INBOUND`].
  ///
  /// [`PIPE_ACCESS_INBOUND`]: https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea#pipe_access_inbound
  ///
  /// # Errors
  ///
  /// Server side prevents connecting by denying inbound access, client errors
  /// with [`std::io::ErrorKind::PermissionDenied`] when attempting to create
  /// the connection.
  ///
  /// ```
  /// use std::io;
  /// use tokio::net::windows::named_pipe::{ClientOptions, ServerOptions};
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\tokio-named-pipe-access-inbound-err1";
  ///
  /// # #[tokio::main] async fn main() -> io::Result<()> {
  /// let _server = ServerOptions::new()
  ///     .access_inbound(false)
  ///     .create(PIPE_NAME)?;
  ///
  /// let e = ClientOptions::new()
  ///     .open(PIPE_NAME)
  ///     .unwrap_err();
  ///
  /// assert_eq!(e.kind(), io::ErrorKind::PermissionDenied);
  /// # Ok(()) }
  /// ```
  ///
  /// Disabling writing allows a client to connect, but errors with
  /// [`std::io::ErrorKind::PermissionDenied`] if a write is attempted.
  ///
  /// ```
  /// use std::io;
  /// use tokio::io::AsyncWriteExt;
  /// use tokio::net::windows::named_pipe::{ClientOptions, ServerOptions};
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\tokio-named-pipe-access-inbound-err2";
  ///
  /// # #[tokio::main] async fn main() -> io::Result<()> {
  /// let server = ServerOptions::new()
  ///     .access_inbound(false)
  ///     .create(PIPE_NAME)?;
  ///
  /// let mut client = ClientOptions::new()
  ///     .write(false)
  ///     .open(PIPE_NAME)?;
  ///
  /// server.connect().await?;
  ///
  /// let e = client.write(b"ping").await.unwrap_err();
  /// assert_eq!(e.kind(), io::ErrorKind::PermissionDenied);
  /// # Ok(()) }
  /// ```
  ///
  /// # Examples
  ///
  /// A unidirectional named pipe that only supports server-to-client
  /// communication.
  ///
  /// ```
  /// use std::io;
  /// use tokio::io::{AsyncReadExt, AsyncWriteExt};
  /// use tokio::net::windows::named_pipe::{ClientOptions, ServerOptions};
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\tokio-named-pipe-access-inbound";
  ///
  /// # #[tokio::main] async fn main() -> io::Result<()> {
  /// let mut server = ServerOptions::new()
  ///     .access_inbound(false)
  ///     .create(PIPE_NAME)?;
  ///
  /// let mut client = ClientOptions::new()
  ///     .write(false)
  ///     .open(PIPE_NAME)?;
  ///
  /// server.connect().await?;
  ///
  /// let write = server.write_all(b"ping");
  ///
  /// let mut buf = [0u8; 4];
  /// let read = client.read_exact(&mut buf);
  ///
  /// let ((), read) = tokio::try_join!(write, read)?;
  ///
  /// assert_eq!(read, 4);
  /// assert_eq!(&buf[..], b"ping");
  /// # Ok(()) }
  /// ```
  Future<void> accessInbound({required bool allowed});

  /// The flow of data in the pipe goes from server to client only.
  ///
  /// This corresponds to setting [`PIPE_ACCESS_OUTBOUND`].
  ///
  /// [`PIPE_ACCESS_OUTBOUND`]: https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea#pipe_access_outbound
  ///
  /// # Errors
  ///
  /// Server side prevents connecting by denying outbound access, client
  /// errors with [`std::io::ErrorKind::PermissionDenied`] when attempting to
  /// create the connection.
  ///
  /// ```
  /// use std::io;
  /// use tokio::net::windows::named_pipe::{ClientOptions, ServerOptions};
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\tokio-named-pipe-access-outbound-err1";
  ///
  /// # #[tokio::main] async fn main() -> io::Result<()> {
  /// let server = ServerOptions::new()
  ///     .access_outbound(false)
  ///     .create(PIPE_NAME)?;
  ///
  /// let e = ClientOptions::new()
  ///     .open(PIPE_NAME)
  ///     .unwrap_err();
  ///
  /// assert_eq!(e.kind(), io::ErrorKind::PermissionDenied);
  /// # Ok(()) }
  /// ```
  ///
  /// Disabling reading allows a client to connect, but attempting to read
  /// will error with [`std::io::ErrorKind::PermissionDenied`].
  ///
  /// ```
  /// use std::io;
  /// use tokio::io::AsyncReadExt;
  /// use tokio::net::windows::named_pipe::{ClientOptions, ServerOptions};
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\tokio-named-pipe-access-outbound-err2";
  ///
  /// # #[tokio::main] async fn main() -> io::Result<()> {
  /// let server = ServerOptions::new()
  ///     .access_outbound(false)
  ///     .create(PIPE_NAME)?;
  ///
  /// let mut client = ClientOptions::new()
  ///     .read(false)
  ///     .open(PIPE_NAME)?;
  ///
  /// server.connect().await?;
  ///
  /// let mut buf = [0u8; 4];
  /// let e = client.read(&mut buf).await.unwrap_err();
  /// assert_eq!(e.kind(), io::ErrorKind::PermissionDenied);
  /// # Ok(()) }
  /// ```
  ///
  /// # Examples
  ///
  /// A unidirectional named pipe that only supports client-to-server
  /// communication.
  ///
  /// ```
  /// use tokio::io::{AsyncReadExt, AsyncWriteExt};
  /// use tokio::net::windows::named_pipe::{ClientOptions, ServerOptions};
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\tokio-named-pipe-access-outbound";
  ///
  /// # #[tokio::main] async fn main() -> std::io::Result<()> {
  /// let mut server = ServerOptions::new()
  ///     .access_outbound(false)
  ///     .create(PIPE_NAME)?;
  ///
  /// let mut client = ClientOptions::new()
  ///     .read(false)
  ///     .open(PIPE_NAME)?;
  ///
  /// server.connect().await?;
  ///
  /// let write = client.write_all(b"ping");
  ///
  /// let mut buf = [0u8; 4];
  /// let read = server.read_exact(&mut buf);
  ///
  /// let ((), read) = tokio::try_join!(write, read)?;
  ///
  /// println!("done reading and writing");
  ///
  /// assert_eq!(read, 4);
  /// assert_eq!(&buf[..], b"ping");
  /// # Ok(()) }
  /// ```
  Future<void> accessOutbound({required bool allowed});

  /// Requests permission to modify the pipe's system access control list.
  ///
  /// This corresponds to setting [`ACCESS_SYSTEM_SECURITY`] in dwOpenMode.
  ///
  /// [`ACCESS_SYSTEM_SECURITY`]: https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea
  Future<void> accessSystemSecurity({required bool requested});

  /// If you attempt to create multiple instances of a pipe with this flag
  /// set, creation of the first server instance succeeds, but creation of any
  /// subsequent instances will fail with
  /// [`std::io::ErrorKind::PermissionDenied`].
  ///
  /// This option is intended to be used with servers that want to ensure that
  /// they are the only process listening for clients on a given named pipe.
  /// This is accomplished by enabling it for the first server instance
  /// created in a process.
  ///
  /// This corresponds to setting [`FILE_FLAG_FIRST_PIPE_INSTANCE`].
  ///
  /// # Errors
  ///
  /// If this option is set and more than one instance of the server for a
  /// given named pipe exists, calling [`create`] will fail with
  /// [`std::io::ErrorKind::PermissionDenied`].
  ///
  /// ```
  /// use std::io;
  /// use tokio::net::windows::named_pipe::ServerOptions;
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\tokio-named-pipe-first-instance-error";
  ///
  /// # #[tokio::main] async fn main() -> io::Result<()> {
  /// let server1 = ServerOptions::new()
  ///     .first_pipe_instance(true)
  ///     .create(PIPE_NAME)?;
  ///
  /// // Second server errs, since it's not the first instance.
  /// let e = ServerOptions::new()
  ///     .first_pipe_instance(true)
  ///     .create(PIPE_NAME)
  ///     .unwrap_err();
  ///
  /// assert_eq!(e.kind(), io::ErrorKind::PermissionDenied);
  /// # Ok(()) }
  /// ```
  ///
  /// # Examples
  ///
  /// ```
  /// use std::io;
  /// use tokio::net::windows::named_pipe::ServerOptions;
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\tokio-named-pipe-first-instance";
  ///
  /// # #[tokio::main] async fn main() -> io::Result<()> {
  /// let mut builder = ServerOptions::new();
  /// builder.first_pipe_instance(true);
  ///
  /// let server = builder.create(PIPE_NAME)?;
  /// let e = builder.create(PIPE_NAME).unwrap_err();
  /// assert_eq!(e.kind(), io::ErrorKind::PermissionDenied);
  /// drop(server);
  ///
  /// // OK: since, we've closed the other instance.
  /// let _server2 = builder.create(PIPE_NAME)?;
  /// # Ok(()) }
  /// ```
  ///
  /// [`create`]: ServerOptions::create
  /// [`FILE_FLAG_FIRST_PIPE_INSTANCE`]: https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea#pipe_first_pipe_instance
  Future<void> firstPipeInstance({required bool first});

  /// The number of bytes to reserve for the input buffer.
  ///
  /// This corresponds to specifying [`nInBufferSize`].
  ///
  /// [`nInBufferSize`]: https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea
  Future<void> inBufferSize({required int buffer});

  /// The maximum number of instances that can be created for this pipe. The
  /// first instance of the pipe can specify this value; the same number must
  /// be specified for other instances of the pipe. Acceptable values are in
  /// the range 1 through 254. The default value is unlimited.
  ///
  /// This corresponds to specifying [`nMaxInstances`].
  ///
  /// [`nMaxInstances`]: https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea
  ///
  /// # Errors
  ///
  /// The same numbers of `max_instances` have to be used by all servers. Any
  /// additional servers trying to be built which uses a mismatching value
  /// might error.
  ///
  /// ```
  /// use std::io;
  /// use tokio::net::windows::named_pipe::{ServerOptions, ClientOptions};
  /// use windows_sys::Win32::Foundation::ERROR_PIPE_BUSY;
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\tokio-named-pipe-max-instances";
  ///
  /// # #[tokio::main] async fn main() -> io::Result<()> {
  /// let mut server = ServerOptions::new();
  /// server.max_instances(2);
  ///
  /// let s1 = server.create(PIPE_NAME)?;
  /// let c1 = ClientOptions::new().open(PIPE_NAME);
  ///
  /// let s2 = server.create(PIPE_NAME)?;
  /// let c2 = ClientOptions::new().open(PIPE_NAME);
  ///
  /// // Too many servers!
  /// let e = server.create(PIPE_NAME).unwrap_err();
  /// assert_eq!(e.raw_os_error(), Some(ERROR_PIPE_BUSY as i32));
  ///
  /// // Still too many servers even if we specify a higher value!
  /// let e = server.max_instances(100).create(PIPE_NAME).unwrap_err();
  /// assert_eq!(e.raw_os_error(), Some(ERROR_PIPE_BUSY as i32));
  /// # Ok(()) }
  /// ```
  ///
  /// # Panics
  ///
  /// This function will panic if more than 254 instances are specified. If
  /// you do not wish to set an instance limit, leave it unspecified.
  ///
  /// ```should_panic
  /// use tokio::net::windows::named_pipe::ServerOptions;
  ///
  /// # #[tokio::main] async fn main() -> std::io::Result<()> {
  /// let builder = ServerOptions::new().max_instances(255);
  /// # Ok(()) }
  /// ```
  Future<void> maxInstances({required BigInt instances});

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new named pipe builder with the default settings.
  ///
  /// ```
  /// use tokio::net::windows::named_pipe::ServerOptions;
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\tokio-named-pipe-new";
  ///
  /// # #[tokio::main] async fn main() -> std::io::Result<()> {
  /// let server = ServerOptions::new().create(PIPE_NAME)?;
  /// # Ok(()) }
  /// ```
  static Future<ServerOptions> newInstance() =>
      RustLib.instance.api.tokioNetWindowsNamedPipeServerOptionsNew();

  /// The number of bytes to reserve for the output buffer.
  ///
  /// This corresponds to specifying [`nOutBufferSize`].
  ///
  /// [`nOutBufferSize`]: https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea
  Future<void> outBufferSize({required int buffer});

  /// The pipe mode.
  ///
  /// The default pipe mode is [`PipeMode::Byte`]. See [`PipeMode`] for
  /// documentation of what each mode means.
  ///
  /// This corresponds to specifying `PIPE_TYPE_` and `PIPE_READMODE_` in  [`dwPipeMode`].
  ///
  /// [`dwPipeMode`]: https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea
  Future<void> pipeMode({required PipeMode pipeMode});

  /// Indicates whether this server can accept remote clients or not. Remote
  /// clients are disabled by default.
  ///
  /// This corresponds to setting [`PIPE_REJECT_REMOTE_CLIENTS`].
  ///
  /// [`PIPE_REJECT_REMOTE_CLIENTS`]: https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea#pipe_reject_remote_clients
  Future<void> rejectRemoteClients({required bool reject});

  /// Requests permission to modify the pipe's discretionary access control list.
  ///
  /// This corresponds to setting [`WRITE_DAC`] in dwOpenMode.
  ///
  /// # Examples
  ///
  /// ```
  /// use std::{io, os::windows::prelude::AsRawHandle, ptr};
  ///
  /// use tokio::net::windows::named_pipe::ServerOptions;
  /// use windows_sys::{
  ///     Win32::Foundation::ERROR_SUCCESS,
  ///     Win32::Security::DACL_SECURITY_INFORMATION,
  ///     Win32::Security::Authorization::{SetSecurityInfo, SE_KERNEL_OBJECT},
  /// };
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\write_dac_pipe";
  ///
  /// # #[tokio::main] async fn main() -> io::Result<()> {
  /// let mut pipe_template = ServerOptions::new();
  /// pipe_template.write_dac(true);
  /// let pipe = pipe_template.create(PIPE_NAME)?;
  ///
  /// unsafe {
  ///     assert_eq!(
  ///         ERROR_SUCCESS,
  ///         SetSecurityInfo(
  ///             pipe.as_raw_handle() as _,
  ///             SE_KERNEL_OBJECT,
  ///             DACL_SECURITY_INFORMATION,
  ///             ptr::null_mut(),
  ///             ptr::null_mut(),
  ///             ptr::null_mut(),
  ///             ptr::null_mut(),
  ///         )
  ///     );
  /// }
  ///
  /// # Ok(()) }
  /// ```
  ///
  /// ```
  /// use std::{io, os::windows::prelude::AsRawHandle, ptr};
  ///
  /// use tokio::net::windows::named_pipe::ServerOptions;
  /// use windows_sys::{
  ///     Win32::Foundation::ERROR_ACCESS_DENIED,
  ///     Win32::Security::DACL_SECURITY_INFORMATION,
  ///     Win32::Security::Authorization::{SetSecurityInfo, SE_KERNEL_OBJECT},
  /// };
  ///
  /// const PIPE_NAME: &str = r"\\.\pipe\write_dac_pipe_fail";
  ///
  /// # #[tokio::main] async fn main() -> io::Result<()> {
  /// let mut pipe_template = ServerOptions::new();
  /// pipe_template.write_dac(false);
  /// let pipe = pipe_template.create(PIPE_NAME)?;
  ///
  /// unsafe {
  ///     assert_eq!(
  ///         ERROR_ACCESS_DENIED,
  ///         SetSecurityInfo(
  ///             pipe.as_raw_handle() as _,
  ///             SE_KERNEL_OBJECT,
  ///             DACL_SECURITY_INFORMATION,
  ///             ptr::null_mut(),
  ///             ptr::null_mut(),
  ///             ptr::null_mut(),
  ///             ptr::null_mut(),
  ///         )
  ///     );
  /// }
  ///
  /// # Ok(()) }
  /// ```
  ///
  /// [`WRITE_DAC`]: https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea
  Future<void> writeDac({required bool requested});

  /// Requests permission to modify the pipe's owner.
  ///
  /// This corresponds to setting [`WRITE_OWNER`] in dwOpenMode.
  ///
  /// [`WRITE_OWNER`]: https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea
  Future<void> writeOwner({required bool requested});
}

/// Indicates the end of a named pipe.
enum PipeEnd {
  /// The named pipe refers to the client end of a named pipe instance.
  ///
  /// Corresponds to [`PIPE_CLIENT_END`].
  ///
  /// [`PIPE_CLIENT_END`]: https://docs.rs/windows-sys/latest/windows_sys/Win32/System/Pipes/constant.PIPE_CLIENT_END.html
  client,

  /// The named pipe refers to the server end of a named pipe instance.
  ///
  /// Corresponds to [`PIPE_SERVER_END`].
  ///
  /// [`PIPE_SERVER_END`]: https://docs.rs/windows-sys/latest/windows_sys/Win32/System/Pipes/constant.PIPE_SERVER_END.html
  server,
  ;
}

/// Information about a named pipe.
///
/// Constructed through [`NamedPipeServer::info`] or [`NamedPipeClient::info`].
class PipeInfo {
  /// Indicates the mode of a named pipe.
  final PipeMode mode;

  /// Indicates the end of a named pipe.
  final PipeEnd end;

  /// The maximum number of instances that can be created for this pipe.
  final int maxInstances;

  /// The number of bytes to reserve for the output buffer.
  final int outBufferSize;

  /// The number of bytes to reserve for the input buffer.
  final int inBufferSize;

  const PipeInfo({
    required this.mode,
    required this.end,
    required this.maxInstances,
    required this.outBufferSize,
    required this.inBufferSize,
  });

  @override
  int get hashCode =>
      mode.hashCode ^
      end.hashCode ^
      maxInstances.hashCode ^
      outBufferSize.hashCode ^
      inBufferSize.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PipeInfo &&
          runtimeType == other.runtimeType &&
          mode == other.mode &&
          end == other.end &&
          maxInstances == other.maxInstances &&
          outBufferSize == other.outBufferSize &&
          inBufferSize == other.inBufferSize;
}

/// The pipe mode of a named pipe.
///
/// Set through [`ServerOptions::pipe_mode`].
enum PipeMode {
  /// Data is written to the pipe as a stream of bytes. The pipe does not
  /// distinguish bytes written during different write operations.
  ///
  /// Corresponds to [`PIPE_TYPE_BYTE`].
  ///
  /// [`PIPE_TYPE_BYTE`]: https://docs.rs/windows-sys/latest/windows_sys/Win32/System/Pipes/constant.PIPE_TYPE_BYTE.html
  byte,

  /// Data is written to the pipe as a stream of messages. The pipe treats the
  /// bytes written during each write operation as a message unit. Any reading
  /// on a named pipe returns [`ERROR_MORE_DATA`] when a message is not read
  /// completely.
  ///
  /// Corresponds to [`PIPE_TYPE_MESSAGE`].
  ///
  /// [`ERROR_MORE_DATA`]: https://docs.rs/windows-sys/latest/windows_sys/Win32/Foundation/constant.ERROR_MORE_DATA.html
  /// [`PIPE_TYPE_MESSAGE`]: https://docs.rs/windows-sys/latest/windows_sys/Win32/System/Pipes/constant.PIPE_TYPE_MESSAGE.html
  message,
  ;
}
