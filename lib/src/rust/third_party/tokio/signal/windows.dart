// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.40.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';


            

            /// Creates a new listener which receives "ctrl-c" notifications sent to the
/// process.
///
/// # Examples
///
/// ```rust,no_run
/// use tokio::signal::windows::ctrl_c;
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn std::error::Error>> {
///     // A listener of CTRL-C events.
///     let mut signal = ctrl_c()?;
///
///     // Print whenever a CTRL-C event is received.
///     for countdown in (0..3).rev() {
///         signal.recv().await;
///         println!("got CTRL-C. {} more to exit", countdown);
///     }
///
///     Ok(())
/// }
/// ```
Future<CtrlC> ctrlC() => RustLib.instance.api.tokioSignalWindowsCtrlC();

/// Creates a new listener which receives "ctrl-break" notifications sent to the
/// process.
///
/// # Examples
///
/// ```rust,no_run
/// use tokio::signal::windows::ctrl_break;
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn std::error::Error>> {
///     // A listener of CTRL-BREAK events.
///     let mut signal = ctrl_break()?;
///
///     // Print whenever a CTRL-BREAK event is received.
///     loop {
///         signal.recv().await;
///         println!("got signal CTRL-BREAK");
///     }
/// }
/// ```
Future<CtrlBreak> ctrlBreak() => RustLib.instance.api.tokioSignalWindowsCtrlBreak();

/// Creates a new listener which receives "ctrl-close" notifications sent to the
/// process.
///
/// # Examples
///
/// ```rust,no_run
/// use tokio::signal::windows::ctrl_close;
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn std::error::Error>> {
///     // A listener of CTRL-CLOSE events.
///     let mut signal = ctrl_close()?;
///
///     // Print whenever a CTRL-CLOSE event is received.
///     for countdown in (0..3).rev() {
///         signal.recv().await;
///         println!("got CTRL-CLOSE. {} more to exit", countdown);
///     }
///
///     Ok(())
/// }
/// ```
Future<CtrlClose> ctrlClose() => RustLib.instance.api.tokioSignalWindowsCtrlClose();

/// Creates a new listener which receives "ctrl-shutdown" notifications sent to the
/// process.
///
/// # Examples
///
/// ```rust,no_run
/// use tokio::signal::windows::ctrl_shutdown;
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn std::error::Error>> {
///     // A listener of CTRL-SHUTDOWN events.
///     let mut signal = ctrl_shutdown()?;
///
///     signal.recv().await;
///     println!("got CTRL-SHUTDOWN. Cleaning up before exiting");
///
///     Ok(())
/// }
/// ```
Future<CtrlShutdown> ctrlShutdown() => RustLib.instance.api.tokioSignalWindowsCtrlShutdown();

/// Creates a new listener which receives "ctrl-logoff" notifications sent to the
/// process.
///
/// # Examples
///
/// ```rust,no_run
/// use tokio::signal::windows::ctrl_logoff;
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn std::error::Error>> {
///     // A listener of CTRL-LOGOFF events.
///     let mut signal = ctrl_logoff()?;
///
///     signal.recv().await;
///     println!("got CTRL-LOGOFF. Cleaning up before exiting");
///
///     Ok(())
/// }
/// ```
Future<CtrlLogoff> ctrlLogoff() => RustLib.instance.api.tokioSignalWindowsCtrlLogoff();

            
                // Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Context < 'static>>>
                abstract class Context implements RustOpaqueInterface {
                    

                    
                }
                


                // Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CtrlBreak>>
                abstract class CtrlBreak implements RustOpaqueInterface {
                    /// Polls to receive the next signal notification event, outside of an
/// `async` context.
///
/// `None` is returned if no more events can be received by this listener.
///
/// # Examples
///
/// Polling from a manually implemented future
///
/// ```rust,no_run
/// use std::pin::Pin;
/// use std::future::Future;
/// use std::task::{Context, Poll};
/// use tokio::signal::windows::CtrlBreak;
///
/// struct MyFuture {
///     ctrl_break: CtrlBreak,
/// }
///
/// impl Future for MyFuture {
///     type Output = Option<()>;
///
///     fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
///         println!("polling MyFuture");
///         self.ctrl_break.poll_recv(cx)
///     }
/// }
/// ```
 Future<PollOption>  pollRecv({required Context cx });


/// Receives the next signal notification event.
///
/// `None` is returned if no more events can be received by this listener.
///
/// # Examples
///
/// ```rust,no_run
/// use tokio::signal::windows::ctrl_break;
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn std::error::Error>> {
///     // A listener of CTRL-BREAK events.
///     let mut signal = ctrl_break()?;
///
///     // Print whenever a CTRL-BREAK event is received.
///     loop {
///         signal.recv().await;
///         println!("got signal CTRL-BREAK");
///     }
/// }
/// ```
 Future<void?>  recv();



                    
                }
                


                // Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CtrlC>>
                abstract class CtrlC implements RustOpaqueInterface {
                    /// Polls to receive the next signal notification event, outside of an
/// `async` context.
///
/// `None` is returned if no more events can be received.
///
/// # Examples
///
/// Polling from a manually implemented future
///
/// ```rust,no_run
/// use std::pin::Pin;
/// use std::future::Future;
/// use std::task::{Context, Poll};
/// use tokio::signal::windows::CtrlC;
///
/// struct MyFuture {
///     ctrl_c: CtrlC,
/// }
///
/// impl Future for MyFuture {
///     type Output = Option<()>;
///
///     fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
///         println!("polling MyFuture");
///         self.ctrl_c.poll_recv(cx)
///     }
/// }
/// ```
 Future<PollOption>  pollRecv({required Context cx });


/// Receives the next signal notification event.
///
/// `None` is returned if no more events can be received by the listener.
///
/// # Examples
///
/// ```rust,no_run
/// use tokio::signal::windows::ctrl_c;
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn std::error::Error>> {
///     let mut signal = ctrl_c()?;
///
///     // Print whenever a CTRL-C event is received.
///     for countdown in (0..3).rev() {
///         signal.recv().await;
///         println!("got CTRL-C. {} more to exit", countdown);
///     }
///
///     Ok(())
/// }
/// ```
 Future<void?>  recv();



                    
                }
                


                // Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CtrlClose>>
                abstract class CtrlClose implements RustOpaqueInterface {
                    /// Polls to receive the next signal notification event, outside of an
/// `async` context.
///
/// `None` is returned if no more events can be received by this listener.
///
/// # Examples
///
/// Polling from a manually implemented future
///
/// ```rust,no_run
/// use std::pin::Pin;
/// use std::future::Future;
/// use std::task::{Context, Poll};
/// use tokio::signal::windows::CtrlClose;
///
/// struct MyFuture {
///     ctrl_close: CtrlClose,
/// }
///
/// impl Future for MyFuture {
///     type Output = Option<()>;
///
///     fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
///         println!("polling MyFuture");
///         self.ctrl_close.poll_recv(cx)
///     }
/// }
/// ```
 Future<PollOption>  pollRecv({required Context cx });


/// Receives the next signal notification event.
///
/// `None` is returned if no more events can be received by this listener.
///
/// # Examples
///
/// ```rust,no_run
/// use tokio::signal::windows::ctrl_close;
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn std::error::Error>> {
///     // A listener of CTRL-CLOSE events.
///     let mut signal = ctrl_close()?;
///
///     // Print whenever a CTRL-CLOSE event is received.
///     signal.recv().await;
///     println!("got CTRL-CLOSE. Cleaning up before exiting");
///
///     Ok(())
/// }
/// ```
 Future<void?>  recv();



                    
                }
                


                // Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CtrlLogoff>>
                abstract class CtrlLogoff implements RustOpaqueInterface {
                    /// Polls to receive the next signal notification event, outside of an
/// `async` context.
///
/// `None` is returned if no more events can be received by this listener.
///
/// # Examples
///
/// Polling from a manually implemented future
///
/// ```rust,no_run
/// use std::pin::Pin;
/// use std::future::Future;
/// use std::task::{Context, Poll};
/// use tokio::signal::windows::CtrlLogoff;
///
/// struct MyFuture {
///     ctrl_logoff: CtrlLogoff,
/// }
///
/// impl Future for MyFuture {
///     type Output = Option<()>;
///
///     fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
///         println!("polling MyFuture");
///         self.ctrl_logoff.poll_recv(cx)
///     }
/// }
/// ```
 Future<PollOption>  pollRecv({required Context cx });


/// Receives the next signal notification event.
///
/// `None` is returned if no more events can be received by this listener.
///
/// # Examples
///
/// ```rust,no_run
/// use tokio::signal::windows::ctrl_logoff;
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn std::error::Error>> {
///     // An listener of CTRL-LOGOFF events.
///     let mut signal = ctrl_logoff()?;
///
///     // Print whenever a CTRL-LOGOFF event is received.
///     signal.recv().await;
///     println!("got CTRL-LOGOFF. Cleaning up before exiting");
///
///     Ok(())
/// }
/// ```
 Future<void?>  recv();



                    
                }
                


                // Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CtrlShutdown>>
                abstract class CtrlShutdown implements RustOpaqueInterface {
                    /// Polls to receive the next signal notification event, outside of an
/// `async` context.
///
/// `None` is returned if no more events can be received by this listener.
///
/// # Examples
///
/// Polling from a manually implemented future
///
/// ```rust,no_run
/// use std::pin::Pin;
/// use std::future::Future;
/// use std::task::{Context, Poll};
/// use tokio::signal::windows::CtrlShutdown;
///
/// struct MyFuture {
///     ctrl_shutdown: CtrlShutdown,
/// }
///
/// impl Future for MyFuture {
///     type Output = Option<()>;
///
///     fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
///         println!("polling MyFuture");
///         self.ctrl_shutdown.poll_recv(cx)
///     }
/// }
/// ```
 Future<PollOption>  pollRecv({required Context cx });


/// Receives the next signal notification event.
///
/// `None` is returned if no more events can be received by this listener.
///
/// # Examples
///
/// ```rust,no_run
/// use tokio::signal::windows::ctrl_shutdown;
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn std::error::Error>> {
///     // A listener of CTRL-SHUTDOWN events.
///     let mut signal = ctrl_shutdown()?;
///
///     // Print whenever a CTRL-SHUTDOWN event is received.
///     signal.recv().await;
///     println!("got CTRL-SHUTDOWN. Cleaning up before exiting");
///
///     Ok(())
/// }
/// ```
 Future<void?>  recv();



                    
                }
                


                // Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Poll < Option < () > >>>
                abstract class PollOption implements RustOpaqueInterface {
                    

                    
                }
                
            